<html>
<head>
<title>A Perl Module Advent Calendar</title></head>
<body bgcolor="#281093" text="white" link="yellow" vlink="yellow">





<p><img src="../../images/2000/24th.jpg" alt="24th" border="0" width="100" height="75">
<hr>




<A NAME="__index__"></A>
<!-- INDEX BEGIN -->

<UL>

	<LI><A HREF="#name">NAME</A></LI>
	<LI><A HREF="#synopsis">SYNOPSIS</A></LI>
	<LI><A HREF="#summary of template directives">SUMMARY OF TEMPLATE DIRECTIVES</A></LI>
	<LI><A HREF="#version">VERSION</A></LI>
	<LI><A HREF="#description">DESCRIPTION</A></LI>
	<LI><A HREF="#methods">METHODS</A></LI>
	<UL>

		<LI><A HREF="#new(\%config)"><CODE>new(\%config)</CODE></A></LI>
		<LI><A HREF="#process($template, \%vars, $output)">process($template, \%vars, $output)</A></LI>
		<LI><A HREF="#error()"><CODE>error()</CODE></A></LI>
		<LI><A HREF="#service()"><CODE>service()</CODE></A></LI>
		<LI><A HREF="#context()"><CODE>context()</CODE></A></LI>
	</UL>

	<LI><A HREF="#template syntax">TEMPLATE SYNTAX</A></LI>
	<LI><A HREF="#template variables">TEMPLATE VARIABLES</A></LI>
	<UL>

		<LI><A HREF="#scalar values">Scalar Values</A></LI>
		<LI><A HREF="#hash array references">Hash Array References</A></LI>
		<LI><A HREF="#list references">List References</A></LI>
		<LI><A HREF="#subroutines">Subroutines</A></LI>
		<LI><A HREF="#objects">Objects</A></LI>
		<LI><A HREF="#parameters and return values">Parameters and Return Values</A></LI>
		<LI><A HREF="#error handling">Error Handling</A></LI>
		<LI><A HREF="#virtual variable methods">Virtual Variable Methods</A></LI>
		<LI><A HREF="#compound variables">Compound Variables</A></LI>
		<LI><A HREF="#variable interpolation">Variable Interpolation</A></LI>
		<LI><A HREF="#local and global variables">Local and Global Variables</A></LI>
		<LI><A HREF="#special variables">Special Variables</A></LI>
	</UL>

	<LI><A HREF="#template directives">TEMPLATE DIRECTIVES</A></LI>
	<UL>

		<LI><A HREF="#accessing and updating template variables">Accessing and Updating Template Variables</A></LI>
		<LI><A HREF="#processing other template files and blocks">Processing Other Template Files and Blocks</A></LI>
		<LI><A HREF="#conditional processing">Conditional Processing</A></LI>
		<LI><A HREF="#loop processing">Loop Processing</A></LI>
		<LI><A HREF="#filters, plugins, macros and perl">Filters, Plugins, Macros and Perl</A></LI>
		<LI><A HREF="#exception handling and flow control">Exception Handling and Flow Control</A></LI>
		<LI><A HREF="#miscellaneous">Miscellaneous</A></LI>
	</UL>

	<LI><A HREF="#configuration options">CONFIGURATION OPTIONS</A></LI>
	<UL>

		<LI><A HREF="#template style and parsing options">Template Style and Parsing Options</A></LI>
		<LI><A HREF="#template files and blocks">Template Files and Blocks</A></LI>
		<LI><A HREF="#template variables">Template Variables</A></LI>
		<LI><A HREF="#runtime processing options">Runtime Processing Options</A></LI>
		<LI><A HREF="#caching and compiling options">Caching and Compiling Options</A></LI>
		<LI><A HREF="#plugins and filters">Plugins and Filters</A></LI>
		<LI><A HREF="#compatibility, customisation and extension">Compatibility, Customisation and Extension</A></LI>
	</UL>

	<LI><A HREF="#template toolkit filters">TEMPLATE TOOLKIT FILTERS</A></LI>
	<LI><A HREF="#template toolkit plugins">TEMPLATE TOOLKIT PLUGINS</A></LI>
	<LI><A HREF="#see also">SEE ALSO</A></LI>
	<LI><A HREF="#author">AUTHOR</A></LI>
	<LI><A HREF="#copyright">COPYRIGHT</A></LI>
	<LI><A HREF="#acknowledgements">ACKNOWLEDGEMENTS</A></LI>
</UL>
<!-- INDEX END -->

<HR>
<P>
<H1><A NAME="name">NAME</A></H1>
<P>Template Toolkit - a fast, flexible and extensible template processing system</P>
<P>
<HR>
<H1><A NAME="synopsis">SYNOPSIS</A></H1>
<PRE>
  use Template;</PRE>
<PRE>
  # some useful options (see below for full list)
  my $config = {
      INCLUDE_PATH =&gt; '/search/path',  # or list ref
      INTERPOLATE  =&gt; 1,               # expand &quot;$var&quot; in plain text
      POST_CHOMP   =&gt; 1,               # cleanup whitespace 
      PRE_PROCESS  =&gt; 'header',        # prefix each template
      EVAL_PERL    =&gt; 1,               # evaluate Perl code blocks
  };</PRE>
<PRE>
  # create Template object
  my $template = Template-&gt;new($config);</PRE>
<PRE>
  # define template variables for replacement
  my $vars = {
      var1  =&gt; $value,
      var2  =&gt; \%hash,
      var3  =&gt; \@list,
      var4  =&gt; \&amp;code,
      var5  =&gt; $object,
  };</PRE>
<PRE>
  # specify input filename, or file handle, text reference, etc.
  my $input = 'myfile.html';</PRE>
<PRE>
  # process input template, substituting variables
  $template-&gt;process($input, $vars)
      || die $template-&gt;error();</PRE>
<P>
<HR>
<H1><A NAME="summary of template directives">SUMMARY OF TEMPLATE DIRECTIVES</A></H1>
<PRE>
  GET       - evaluate and print a variable or value
              [%   GET variable %]    # 'GET' keyword is optional
              [%       variable %]
              [%       hash.key %]
              [%         list.n %]
              [%     code(args) %]
              [% obj.meth(args) %]
              [%  &quot;value: $var&quot; %]</PRE>
<PRE>
  CALL      - as above without printing result (e.g. call code)
              [%  CALL variable %]</PRE>
<PRE>
  SET       - assign a value to a variable
              [% SET variable = value %]    # 'SET' also optional
              [%     variable = other_variable
                     variable = 'literal text @ $100'
                     variable = &quot;interpolated text: $var&quot;
                     list     = [ val, val, val, val, ... ]
                     list     = [ val..val ]
                     hash     = { var =&gt; val, var =&gt; val, ... }
              %]</PRE>
<PRE>
  DEFAULT   - as SET above, if variable(s) not set
              [% DEFAULT variable = value %]</PRE>
<PRE>
  INSERT    - insert a file without any processing
              [% INSERT legalese.txt %]</PRE>
<PRE>
  INCLUDE   - process another template file/block, localising vars
              [% INCLUDE template %]
              [% INCLUDE template  var = val, ... %]</PRE>
<PRE>
  PROCESS   - as above, without localising variables
              [% PROCESS template %]
              [% PROCESS template  var = val, ... %]</PRE>
<PRE>
  WRAPPER   - process a template to enclose specified block
              [% WRAPPER template %]
                 content
              [% END %]</PRE>
<PRE>
  BLOCK     - define a named template block for INCLUDE, etc.
              [% BLOCK template %]
                 content
              [% END %]</PRE>
<PRE>
  FOREACH   - repeat block for each value in a list
              [% FOREACH variable = [ val, val, val ] %]
              [% FOREACH variable = list %]
              [% FOREACH list %]
                 content...
                 [% variable %]
              [% END %]</PRE>
<PRE>
  WHILE     - iterate while condition is true
              [% WHILE condition %]
                 content
              [% END %]</PRE>
<PRE>
  IF / UNLESS / ELSIF / ELSE
            - process block if condition is true/false.
              [% IF condition %]
                 content
              [% ELSIF condition %]
                 content
              [% ELSE %]
                 content
              [% END %]</PRE>
<PRE>
              [% UNLESS condition %]
                 content
              [% # ELSIF/ELSE as per IF, above %]
                 content
              [% END %]</PRE>
<PRE>
  SWITCH / CASE
            - multi-way switch/case statement
              [% SWITCH variable %]
              [% CASE val1 %]
                 content
              [% CASE [ val2, val3 ] %]
                 content
              [% CASE %]         # or [% CASE DEFAULT %]
                 content
              [% END %]</PRE>
<PRE>
  MACRO     - create a named macro for some other directive or block
              [% MACRO name &lt;directive&gt; %]
              [% MACRO name(arg1, arg2) &lt;directive&gt; %]
              ...
              [% name %]
              [% name(val1, val2) %]</PRE>
<PRE>
  FILTER    - post-process block through a filter
              [% FILTER name %]
              [% FILTER name( params ) %]
              [% FILTER alias = name( params ) %]
                 content
              [% END %]</PRE>
<PRE>
  USE       - load a &quot;plugin&quot; module (or any regular Perl module 
              with LOAD_PERL option)
              [% USE name %]
              [% USE name( params ) %] 
              [% USE var = name( params ) %]
              ...
              [% name.method %]
              [% var.method %]</PRE>
<PRE>
  PERL / RAWPERL
            - evaluate blocks of Perl code (requires EVAL_PERL option)
              [% PERL %]
                 # perl code goes here
                 $stash-&gt;set('foo', 10);
                 print &quot;set 'foo' to &quot;, $stash-&gt;get('foo'), &quot;\n&quot;;
                 print $context-&gt;include('footer', { var =&gt; $val });
              [% END %]</PRE>
<PRE>
              [% RAWPERL %]
                 # raw perl code goes here, no magic but fast.
                 $output .= 'some output';
              [% END %]</PRE>
<PRE>
  TRY / THROW / CATCH / FINAL
            - exception handling
              [% TRY %]
                 content
                 [% THROW type info %]
              [% CATCH type %]
                 catch content
                 [% error.type %] [% error.info %]
              [% CATCH %]       # or [% CATCH DEFAULT %]
                 content
              [% FINAL %]
                 this block is always processed
              [% END %]</PRE>
<PRE>
  NEXT      - next item in a FOREACH/WHILE loop
              [% NEXT %]
</PRE>
<PRE>

  LAST      - break out of FOREACH/WHILE loop
              [% LAST %]</PRE>
<PRE>

  RETURN    - stop processing current template
              [% RETURN %]</PRE>
<PRE>
  STOP      - stop processing all templates and return to caller
              [% STOP %]</PRE>
<PRE>
  COMMENT   - ignored and deleted
              [% # this is a comment to the end of line
                 foo = 'bar'
              %]</PRE>
<PRE>
              [%# placing the '#' immediately inside the directive
                  tag comments out the entire directive
              %]</PRE>
<PRE>
  TAGS      - define new tag style or characters (default: [% %])
              [% TAGS html %]
              [% TAGS &lt;!-- --&gt; %]</PRE>
<P>
<HR>
<H1><A NAME="version">VERSION</A></H1>
<P>This is version 2.00-rc2 of the Template Toolkit.</P>
<P>Please consult the <EM>Changes</EM> file for information about visible changes
in the Template Toolkit between releases.  The <EM>TODO</EM> file contains 
details of known bugs, planned enhancements, features, fixes, etc.</P>
<P>The latest version of the Template Toolkit can be downloaded from any 
CPAN site in the directory:</P>
<PRE>
    /modules/by-module/Template/</PRE>
<P>For a list of CPAN sites, see:</P>
<PRE>
    <A HREF="http://www.cpan.org/">http://www.cpan.org/</A></PRE>
<P>Information regarding interim and development versions is posted to the
templates mailing list and available from the Template Toolkit web site:</P>
<PRE>
    <A HREF="http://www.template-toolkit.org/">http://www.template-toolkit.org/</A></PRE>
<P>
<HR>
<H1><A NAME="description">DESCRIPTION</A></H1>
<P>The Template Toolkit is a collection of modules which implement a
fast, flexible, powerful and extensible template processing system.
It was originally designed and remains primarily useful for generating
dynamic web content, but it can be used equally well for processing
any kind of text documents.  This POD documentation is all generated
using the Template Toolkit batch mode utility <EM>ttree</EM>, for example.</P>
<P>At the simplest level it provides an easy way to process template
files, filling in embedded variable references with their equivalent
values.</P>
<PRE>
    Dear [% name %],</PRE>
<PRE>
    It has come to our attention that your account is in 
    arrears to the sum of [% debt %].</PRE>
<PRE>
    Please settle your account before [% deadline %] or we 
    will be forced to revoke your Licence to Thrill.</PRE>
<PRE>
    The Management.</PRE>
<P>By default, template directives are embedded within the character
sequences '[%' ... '%]' but you can change these and various other
options to configure how the Template Toolkit looks, feels and works.
You can set the INTERPOLATE option, for example, if you prefer to
embed your variables in Perl style:</P>
<PRE>
    Dear $name,</PRE>
<PRE>
    It has come to our attention that your account is in 
    arrears to the sum of $debt.
    ...</PRE>
<P>The Template.pm module is the front end to the Template Toolkit,
providing access to the full range of functionality through a single
module with a simple interface.  It loads the other modules as
required and instantiates a default set of objects to handle
subsequent template processing requests.  Configuration parameters may
be passed to the Template.pm constructor, new(), which are then used
to configure the underlying objects.</P>
<PRE>
    use Template;</PRE>
<PRE>
    my $tt = Template-&gt;new({
        INCLUDE_PATH =&gt; '/usr/local/templates',
        INTERPOLATE  =&gt; 1,
    }) || die &quot;$Template::ERROR\n&quot;;</PRE>
<P>The Template object implements a <CODE>process()</CODE> method for processing template
files or text.  The name of the input template (or various other sources) 
is passed as the first argument, followed by a reference to a hash array 
of variable definitions for substitution in the template.</P>
<PRE>
    my $vars = {
        name     =&gt; 'Count Edward van Halen',
        debt     =&gt; '3 riffs and a solo',
        deadline =&gt; 'the next chorus',
    };</PRE>
<PRE>
    $template-&gt;process('letters/overdrawn', $vars)
        || die $template-&gt;error(), &quot;\n&quot;;</PRE>
<P>The <CODE>process()</CODE> method returns true (1) on success and prints the
template output to STDOUT, by default.  On error, the <CODE>process()</CODE> method
returns false (undef).  The <A HREF="#item_error"><CODE>error()</CODE></A> method can then be called to
retrieve details of the error.</P>
<P>A number of special directives are provided, such as INSERT, INCLUDE
and PROCESS, which allow content to be built up from smaller template
components.  This permits a modular approach to building a web site or
other content repository, promoting reusability, cross-site
consistency, ease of construction and subsequent maintenance.  Common
elements such as headers, footers, menu bars, tables, and so on, can
be created as separate template files which can then be processed into
other documents as required.  All defined variables are inherited by
these templates along with any additional ``local'' values specified.</P>
<PRE>
    [% PROCESS header 
         title = &quot;The Cat Sat on the Mat&quot;
    %]</PRE>
<PRE>
    [% PROCESS menu %]</PRE>
<PRE>
    The location of the missing feline has now been established.
    Thank you for your assistance.</PRE>
<PRE>
    [% INSERT legal/disclaimer %]</PRE>
<PRE>
    [% PROCESS footer %]</PRE>
<P>You can also define a template as a BLOCK within the same file and
PROCESS it just like any other template file.  This can be invaluable
for building up repetitive elements such as tables, menus, etc.</P>
<PRE>
    [% BLOCK tabrow %]
       &lt;tr&gt;&lt;td&gt;[% name %]&lt;/td&gt;&lt;td&gt;[% email %]&lt;/td&gt;&lt;/tr&gt;
    [% END %]</PRE>
<PRE>
    &lt;table&gt;
    [% PROCESS tabrow name=&quot;tom&quot;   email=&quot;tom@here.org&quot;    %]
    [% PROCESS tabrow name=&quot;dick&quot;  email=&quot;disk@there.org&quot;  %]
    [% PROCESS tabrow name=&quot;larry&quot; email=&quot;larry@where.org&quot; %]
    &lt;/table&gt;</PRE>
<P>One of the key features that sets the Template Toolkit apart from
other template processors is the ability to bind template variables to
any kind of Perl data: scalars, lists, hash arrays, sub-routines and
objects.</P>
<PRE>
    my $vars = {
        root   =&gt; '<A HREF="http://here.com/there">http://here.com/there</A>',
        menu   =&gt; [ 'modules', 'authors', 'scripts' ],
        client =&gt; {
            name =&gt; 'Doctor Joseph von Satriani',
            id   =&gt; 'JVSAT',
        },
        checkout =&gt; sub { my $total = shift; ...; return $something },
        shopcart =&gt; My::Cool::Shopping::Cart-&gt;new(),
    };</PRE>
<P>The Template Toolkit will automatically Do The Right Thing to access
the data in an appropriate manner to return some value which can then
be output.  The dot operator '.' is used to accesses into lists and
hashes or to call object methods.  The FOREACH directive is provided for
iterating through lists, and various logicial tests are available using
directives such as IF, UNLESS, ELSIF, ELSE, SWITCH, CASE, etc.</P>
<PRE>
    [% FOREACH section = menu %]
       &lt;a href=&quot;[% root %]/[% section %]/index.html&quot;&gt;[% section %]&lt;/a&gt;
    [% END %]</PRE>
<PRE>
    &lt;b&gt;Client&lt;/a&gt;: [% client.name %] (id: [% client.id %])
</PRE>
<PRE>

    [% IF shopcart.nitems %]
       Your shopping cart contains the following items:
       &lt;ul&gt;
       [% FOREACH item = shopcart.contents %]
          &lt;li&gt;[% item.name %] : [% item.qty %] @ [% item.price %]
       [% END %]
       &lt;/ul&gt;</PRE>
<PRE>
       [% checkout(shopcart.total) %]</PRE>
<PRE>
    [% ELSE %]
       No items currently in shopping cart.
    [% END %]</PRE>
<P>The Template Toolkit also provides a number of additional directives
for advanced processing and programmatical functionality.  It supports
output filters (FILTER), allows custom macros to be defined (MACRO),
has a fully-featured exception handling system (TRY, THROW, CATCH,
FINAL) and supports a plugin architecture (USE) which allows special
plugin modules and even regular Perl modules to be loaded and used
with the minimum of fuss.  The Template Toolkit is ``just'' a template
processor but you can trivially extend it to incorporate the
functionality of any Perl module you can get your hands on.  Thus, it
is also a scalable and extensible template framework, ideally suited
for managing the presentation layer for application servers, content
management systems and other web applications.</P>
<P>Rather than embedding Perl code or some other scripting language
directly into template documents, it encourages you to keep functional
components (i.e. Perl code) separate from presentation components
(e.g. HTML templates).  The template variables provide the interface
between the two layers, allowing data to be generated in code and then
passed to a template component for displaying (pipeline model) or for
sub-routine or object references to be bound to variables which can
then be called from the template as and when required (callback
model).</P>
<P>The directives that the Template Toolkit provide implement their own
mini programming language, but they're not really designed for
serious, general purpose programming.  Perl is a far more appropriate
language for that.  If you embed application logic (e.g. Perl or other
scripting language fragments) in HTML templates then you risk losing
the clear separation of concerns between functionality and
presentation.  It becomes harder to maintain the two elements in
isolation and more difficult, if not impossible, to reuse code or
presentation elements by themselves.  It is far better to write your
application code in separate Perl modules, libraries or scripts and
then use templates to control how the resulting data is presented as
output.  Thus you should think of the Template Toolkit language as a
set of layout directives for displaying data, not calculating it.</P>
<P>Having said that, the Template Toolkit doesn't force you into one
approach or the other.  It attempts to be pragmatic rather than
dogmatic in allowing you to do whatever best gets the job done.
Thus, if you enable the EVAL_PERL option then you can happily embed
real Perl code in your templates within PERL ... END directives.</P>
<P>The Template Toolkit uses a fast YACC-like parser which compiles
templates into Perl code for maximum runtime efficiency.  It also has
an advanced caching mechanism which manages in-memory and on-disk
(i.e. persistant) versions of compiled templates.  The modules that
comprise the toolkit are highly configurable and the architecture
around which they're built is designed to be extensible.  The Template
Toolkit provides a powerful framework around which content creation
and delivery systems can be built while also providing a simple
interface through the Template front-end module for general use.</P>
<P>
<HR>
<H1><A NAME="methods">METHODS</A></H1>
<P>
<H2><A NAME="new(\%config)"><CODE>new(\%config)</CODE></A></H2>
<P>The <CODE>new()</CODE> constructor method (implemented by the Template::Base base
class) instantiates a new Template object.  A reference to a hash
array of configuration items may be passed as a parameter.</P>
<PRE>
    my $tt = Template-&gt;new({
        INCLUDE_PATH =&gt; '/usr/local/templates',
        EVAL_PERL    =&gt; 1,
    }) || die $Template::ERROR, &quot;\n&quot;;</PRE>
<P>A reference to a new Template object is returned, or undef on error.
In the latter case, the error message can be retrieved by calling
<A HREF="#item_error"><CODE>error()</CODE></A> as a class method (e.g. <A HREF="#item_error"><CODE>Template-&gt;error()</CODE></A>) or by
examining the $ERROR package variable directly
(e.g. <CODE>$Template::ERROR</CODE>).</P>
<PRE>
    my $tt = Template-&gt;new(\%config)
        || die Template-&gt;error(), &quot;\n&quot;;</PRE>
<PRE>
    my $tt = Template-&gt;new(\%config)
        || die $Template::ERROR, &quot;\n&quot;;</PRE>
<P>For convenience, configuration items may also be specified as a list
of items instead of a hash array reference.  These are automatically
folded into a hash array by the constructor.</P>
<PRE>
    my $tt = Template-&gt;new(INCLUDE_PATH =&gt; '/tmp', POST_CHOMP =&gt; 1)
        || die $Template::ERROR, &quot;\n&quot;;</PRE>
<P>
<H2><A NAME="process($template, \%vars, $output)">process($template, \%vars, $output)</A></H2>
<P>The <CODE>process()</CODE> method is called to process a template.  The first
parameter indicates the input template as one of: a filename relative
to INCLUDE_PATH, if defined; a reference to a text string containing
the template text; or a file handle reference (e.g. IO::Handle or
sub-class) or GLOB (e.g. \*STDIN), from which the template can be
read.  A reference to a hash array may be passed as the second
parameter, containing definitions of template variables.</P>
<PRE>
    $text = &quot;[% INCLUDE header %]\nHello world!\n[% INCLUDE footer %]&quot;;</PRE>
<PRE>
    # filename
    $tt-&gt;process('welcome.tt2')
        || die $tt-&gt;error(), &quot;\n&quot;;</PRE>
<PRE>
    # text reference
    $tt-&gt;process(\$text)
        || die $tt-&gt;error(), &quot;\n&quot;;</PRE>
<PRE>
    # GLOB
    $tt-&gt;process(\*DATA)
        || die $tt-&gt;error(), &quot;\n&quot;;</PRE>
<PRE>
    __END__
    [% INCLUDE header %]
    This is a template defined in the __END__ section which is 
    accessible via the DATA &quot;file handle&quot;.
    [% INCLUDE footer %]</PRE>
<P>By default, the processed template output is printed to STDOUT.  The
<CODE>process()</CODE> method then returns 1 to indicate success.  A third
parameter may be passed to the <CODE>process()</CODE> method to specify a different
output location.  This value may be one of: a plain string indicating
a filename which will be opened (relative to OUTPUT_PATH, if defined)
and the output written to; a file GLOB opened ready for output; a
reference to a scalar (e.g. a text string) to which output/error is
appended; a reference to a subroutine which is called, passing the
output as a parameter; or any object reference which implements a
'print' method (e.g. IO::Handle, Apache::Request, etc.) which will 
be called, passing the generated output as a parameter.</P>
<P>Examples:</P>
<PRE>
    # output filename
    $tt-&gt;process('welcome.tt2', $vars, 'welcome.html')
        || die $tt-&gt;error(), &quot;\n&quot;;</PRE>
<PRE>
    # reference to output subroutine
    sub myout {
        my $output = shift;
        ...
    }
    $tt-&gt;process('welcome.tt2', $vars, \&amp;myout)
        || die $tt-&gt;error(), &quot;\n&quot;;</PRE>
<PRE>
    # reference to output text string
    my $output = '';
    $tt-&gt;process('welcome.tt2', $vars, \$output)
        || die $tt-&gt;error(), &quot;\n&quot;;
</PRE>
<PRE>

    print &quot;output: $output\n&quot;;</PRE>
<P>In an Apache/mod_perl handler:</P>
<PRE>
    sub handler {
        my $req = shift;</PRE>
<PRE>
        ...</PRE>
<PRE>
        # direct output to Apache::Request via $req-&gt;print($output)
        $tt-&gt;process($file, $vars, $req) || do {
            $req-&gt;log_reason($tt-&gt;error());
            return SERVER_ERROR;
        };</PRE>
<PRE>
        return OK;
    }</PRE>
<P>The OUTPUT configuration item can be used to specify a default output 
location other than \*STDOUT.  The OUTPUT_PATH specifies a directory
which should be prefixed to all output locations specified as filenames.</P>
<PRE>
    my $tt = Template-&gt;new({
        OUTPUT      =&gt; sub { ... },       # default
        OUTPUT_PATH =&gt; '/tmp',
        ...
    }) || die Template-&gt;error(), &quot;\n&quot;;</PRE>
<PRE>
    # use default OUTPUT (sub is called)
    $tt-&gt;process('welcome.tt2', $vars)
        || die $tt-&gt;error(), &quot;\n&quot;;</PRE>
<PRE>
    # write file to '/tmp/welcome.html'
    $tt-&gt;process('welcome.tt2', $vars, 'welcome.html')
        || die $tt-&gt;error(), &quot;\n&quot;;</PRE>
<P>The <CODE>process()</CODE> method returns 1 on success or undef on error.  The error
message generated in the latter case can be retrieved by calling the
<A HREF="#item_error"><CODE>error()</CODE></A> method.  See also <A HREF="#configuration options">CONFIGURATION OPTIONS</A> which describes how
error handling may be further customised.</P>
<P>
<H2><A NAME="error()"><A HREF="#item_error"><CODE>error()</CODE></A></A></H2>
<P>When called as a class method, it returns the value of the $ERROR package
variable.  Thus, the following are equivalent.</P>
<PRE>
    my $tt = Template-&gt;new()
        || die Template-&gt;error(), &quot;\n&quot;;</PRE>
<PRE>
    my $tt = Template-&gt;new()
        || die $Template::ERROR, &quot;\n&quot;;</PRE>
<P>When called as an object method, it returns the value of the internal
_ERROR variable, as set by an error condition in a previous call to
process().</P>
<PRE>
    $tt-&gt;process('welcome.tt2')
        || die $tt-&gt;error(), &quot;\n&quot;;</PRE>
<P>Errors are represented in the Template Toolkit by objects of the
Template::Exception class.  If the <CODE>process()</CODE> method returns a false
value then the <A HREF="#item_error"><CODE>error()</CODE></A> method can be called to return an object of
this class.  The <CODE>type()</CODE> and <CODE>info()</CODE> methods can called on the object to
retrieve the error type and information string, respectively.  The
<CODE>as_string()</CODE> method can be called to return a string of the form ``$type
- $info''.  This method is also overloaded onto the stringification
operator allowing the object reference itself to be printed to return
the formatted error string.</P>
<PRE>
    $tt-&gt;process('somefile') || do {
        my $error = $tt-&gt;error();
        print &quot;error type: &quot;, $error-&gt;type(), &quot;\n&quot;;
        print &quot;error info: &quot;, $error-&gt;info(), &quot;\n&quot;;
        print $error, &quot;\n&quot;;
    };</PRE>
<P>
<H2><A NAME="service()"><CODE>service()</CODE></A></H2>
<P>The Template module delegates most of the effort of processing templates
to an underlying Template::Service object.  This method returns a reference
to that object.</P>
<P>
<H2><A NAME="context()"><CODE>context()</CODE></A></H2>
<P>The Template::Service module uses a core Template::Context object for
runtime processing of templates.  This method returns a reference to 
that object and is equivalent to $template-&gt;service-&gt;context();</P>
<P>
<HR>
<H1><A NAME="template syntax">TEMPLATE SYNTAX</A></H1>
<P>By default, template directives are embedded within the character sequences
'[%' and '%]'.  e.g.</P>
<PRE>
    [% PROCESS header %]
</PRE>
<PRE>

    &lt;h1&gt;Hello World!&lt;/h1&gt;
    &lt;a href=&quot;[% page.next %]&quot;&gt;&lt;img src=&quot;[% icon.next %].gif&quot;&gt;&lt;/a&gt;</PRE>
<PRE>

    [% PROCESS footer %]</PRE>
<P>You can change the tag characters using the START_TAG, END_TAG and
TAG_STYLE configuration options.  You can also use the TAGS directive
to define a new tag style for the current template file.</P>
<P>Directives may be embedded anywhere in a line of text and can be split
across several lines.  Insignificant whitespace is generally ignored
within the directive.</P>
<PRE>
    [% INCLUDE header              
       title = 'Hello World' 
       bgcol = '#ffffff' 
    %]
</PRE>
<PRE>

    [%INCLUDE menu align='right'%]</PRE>
<PRE>

    Name: [% name %]  ([%id%])</PRE>
<P>You can also set the INTERPOLATE option to allow simple variable
references to be embedded directly in templates, prefixed by a '$'.</P>
<PRE>
    # INTERPOLATE =&gt; 0
    &lt;td&gt;[% name %]&lt;/td&gt;  &lt;td&gt;[% email %]&lt;/td&gt;</PRE>
<PRE>
    # INTERPOLATE =&gt; 1
    &lt;td&gt;$name&lt;/td&gt;  &lt;td&gt;$email&lt;/td&gt;</PRE>
<P>The '#' character is used to indicate comments within a directive.
When placed immediately inside the opening directive tag, it causes
the entire directive to be ignored.</P>
<PRE>
    [%# this entire directive is ignored no
        matter how many lines it wraps onto
    %]</PRE>
<P>In any other position, it causes the remainder of the current line to 
be treated as a comment.</P>
<PRE>
    [% # this is a comment
       theta = 20      # so is this
       rho   = 30      # &lt;aol&gt;me too!&lt;/aol&gt;
    %]</PRE>
<P>You can add '-' or '+' to the immediate start or end of a directive
tag to control the whitespace chomping options.  See the PRE_CHOMP and
POST_CHOMP options for further details.</P>
<PRE>
    [% BLOCK foo -%]            # remove trailing newline
    This is block foo
    [%- END %]                  # remove leading newline</PRE>
<P>The simplest directives are GET and SET which retrieve and update
variable values respectively.  The GET and SET keywords are actually
optional as the parser is smart enough to see them for what they
really are (but note the caveat below on using side-effect notation).
Thus, you'll generally see:</P>
<PRE>
    [% SET foo = 10 %]
    [% GET foo %]</PRE>
<P>written as:</P>
<PRE>
    [% foo = 10 %]
    [% foo %]</PRE>
<P>You can also express simple logical statements as implicit GET directives:</P>
<PRE>
    [% title or template.title or 'Default Title' %]</PRE>
<PRE>
    [% mode == 'graphics' ? &quot;Graphics Mode Enabled&quot; : &quot;Text Mode&quot; %]</PRE>
<P>All other directives should start with a keyword specified in UPPER
CASE (but see the ANYCASE option).  All directives keywords are in
UPPER CASE to make them visually distinctive and to distinguish them
from variables of the same name but different case.  It is perfectly
valid, for example, to define a variable called 'stop' which is
entirely separate from the STOP directive.</P>
<PRE>
    [% stop = 'Clackett Lane Bus Depot' %]</PRE>
<PRE>
    The bus will next stop at [% stop %]    # variable</PRE>
<PRE>
    [% STOP %]                              # directive</PRE>
<P>Directives such as FOREACH, WHILE, BLOCK, FILTER, etc., mark the start
of a block which may contain text or other directives up to the
matching END directive.  Blocks may be nested indefinately.  The
IF, UNLESS, ELSIF and ELSE directives also define blocks and may be
grouped together in the usual manner.</P>
<PRE>
    [% FOREACH item = [ 'foo' 'bar' 'baz' ] %]
       * Item: [% item %]
    [% END %]
</PRE>
<PRE>

    [% BLOCK footer %]
       Copyright 2000 [% me %]
       [% INCLUDE company/logo %]
    [% END %]</PRE>
<PRE>

    [% IF foo %]
       [% FOREACH thing = foo.things %]
          [% thing %]
       [% END %]
    [% ELSIF bar %]
       [% INCLUDE barinfo %]
    [% ELSE %]
       do nothing...
    [% END %]</PRE>
<P>Block directives can also be used in a convenient side-effect notation.</P>
<PRE>
    [% INCLUDE userinfo FOREACH user = userlist %]</PRE>
<PRE>
    [% INCLUDE debugtxt msg=&quot;file: $error.info&quot; 
         IF debugging %]</PRE>
<PRE>
    [% &quot;Danger Will Robinson&quot; IF atrisk %]</PRE>
<P>versus:</P>
<PRE>
    [% FOREACH user = userlist %]
       [% INCLUDE userinfo %]
    [% END %]</PRE>
<PRE>
    [% IF debugging %]
       [% INCLUDE debugtxt msg=&quot;file: $error.info&quot; %]
    [% END %]</PRE>
<PRE>
    [% IF atrisk %]
    Danger Will Robinson
    [% END %]</PRE>
<P>The output of a directive can be captured by simply assigning the directive
to a variable.</P>
<PRE>
    [% headtext = PROCESS header title=&quot;Hello World&quot; %]</PRE>
<PRE>
    [% people = PROCESS userinfo FOREACH user = userlist %]</PRE>
<P>This can be used in conjunction with the BLOCK directive for defining large 
blocks of text or other content.</P>
<PRE>
    [% poem = BLOCK %]
       The boy stood on the burning deck,
       His fleece was white as snow.
       A rolling stone gathers no moss,
       And Keith is sure to follow.
    [% END %]</PRE>
<P>Note one important caveat of using this syntax in conjunction with side-effect
notation.  The following directive does not behave as might be expected:</P>
<PRE>
    [% var = 'value' IF some_condition %]</PRE>
<P>In this case, the directive is interpreted as (spacing added for clarity)</P>
<PRE>
    [% var = IF some_condition %]
       value
    [% END %]</PRE>
<P>rather than</P>
<PRE>
    [% IF some_condition %]
       [% var = 'value' %]
    [% END %]</PRE>
<P>The variable is assigned the output of the IF block which returns
'value' if true, but nothing if false.  In other words, the following
directive will always cause 'var' to be cleared.</P>
<PRE>
    [% var = 'value' IF 0 %]</PRE>
<P>To achieve the expected behaviour, the directive should be written as:</P>
<PRE>
    [% SET var = 'value' IF some_condition %]</PRE>
<P>Multiple FILTER directives can be chained together in sequence.  They
are called in the order defined, piping the output of one into the 
input of the next.</P>
<PRE>
    [% PROCESS somefile FILTER truncate(100) FILTER html %]</PRE>
<P>The pipe character, '|', can also be used as an alias for FILTER.</P>
<PRE>
    [% PROCESS somefile | truncate(100) | html %]</PRE>
<P>Multiple directives can be included within a single tag when delimited
by semi-colons, ';'.  Note however that the TAGS directive must always
be specified in a tag by itself.</P>
<PRE>
    [% IF title; 
          INCLUDE header; 
       ELSE; 
          INCLUDE other/header  title=&quot;Some Other Title&quot;;
       END
    %]</PRE>
<P>versus</P>
<PRE>
    [% IF title %]
       [% INCLUDE header %]
    [% ELSE %]
       [% INCLUDE other/header  title=&quot;Some Other Title&quot; %]
    [% END %]</PRE>
<P>
<HR>
<H1><A NAME="template variables">TEMPLATE VARIABLES</A></H1>
<P>A reference to a hash array may be passed as the second argument to
the <CODE>process()</CODE> method, containing definitions of template variables.
The VARIABLES (a.k.a. PRE_DEFINE) option can also be used to pre-define
variables for all templates processed by the object.</P>
<PRE>
    my $tt = Template-&gt;new({
        VARIABLES =&gt; {
            version =&gt; 3.14,
            release =&gt; 'Sahara',
        },
    });</PRE>
<PRE>
    my $vars = {
        serial_no =&gt; 271828,
    };</PRE>
<PRE>
    $tt-&gt;process('myfile', $vars);</PRE>
<P>'myfile':</P>
<PRE>
    This is version [% version %] ([% release %]).
    Serial number: [% serial_no %]</PRE>
<P>output:</P>
<PRE>
    This is version 3.14 (Sahara)
    Serial number: 271828</PRE>
<P>Variable names may contain any alphanumeric characters or underscores.
They may be lower, upper or mixed case although the usual convention
is to use lower case.  The case <EM>is</EM> significant however, and 'foo',
'Foo' and 'FOO' are all different variables.  Upper case variable
names are permitted, but not recommended due to a possible conflict
with an existing or future reserved word.  As of version 2.00, these
are:</P>
<PRE>
    GET CALL SET DEFAULT INSERT INCLUDE PROCESS WRAPPER 
    IF UNLESS ELSE ELSIF FOR FOREACH WHILE SWITCH CASE
    USE PLUGIN FILTER MACRO PERL RAWPERL BLOCK META
    TRY THROW CATCH FINAL NEXT LAST BREAK RETURN STOP 
    CLEAR TO STEP AND OR NOT MOD DIV END</PRE>
<P>The variable values may be of virtually any Perl type, including
simple scalars, references to lists, hash arrays, subroutines or
objects.  The Template Toolkit will automatically apply the correct
procedure to accessing these values as they are used in the template.</P>
<P>Example:</P>
<PRE>
    my $vars = {
        article =&gt; 'The Third Shoe',
        person  =&gt; { 
            id    =&gt; 314, 
            name  =&gt; 'Mr. Blue',
            email =&gt; 'blue@nowhere.org',
        },
        primes  =&gt; [ 2, 3, 5, 7, 11, 13 ],
        wizard  =&gt; sub { return join(' ', 'Abracadabra!', @_) },
        cgi     =&gt; CGI-&gt;new('mode=submit&amp;debug=1'),
    };</PRE>
<P>template:</P>
<PRE>
    [% article %]</PRE>
<PRE>
    [% person.id %]: [% person.name %] &lt;[% person.email %]&gt;</PRE>
<PRE>
    [% primes.first %] - [% primes.last %], including [% primes.3 %]
    [% primes.size %] prime numbers: [% primes.join(', ') %]</PRE>
<PRE>
    [% wizard %]
    [% wizard('Hocus Pocus!') %]</PRE>
<PRE>
    [% cgi.param('mode') %]</PRE>
<P>output:</P>
<PRE>
    The Third Shoe</PRE>
<PRE>
    314: Mr. Blue &lt;blue@nowhere.org&gt;</PRE>
<PRE>
    2 - 13, including 7
    6 prime numbers: 2, 3, 5, 7, 11, 13</PRE>
<PRE>
    Abracadabra!
    Abracadabra! Hocus Pocus!
</PRE>
<PRE>

    submit</PRE>
<P>
<H2><A NAME="scalar values">Scalar Values</A></H2>
<P>Regular scalar variables are accessed by simply specifying their name.
As these are just entries in the top-level variable hash they can be 
considered special cases of hash array referencing as described below,
with the main namespace hash automatically implied.</P>
<PRE>
    [% article %]</PRE>
<P>
<H2><A NAME="hash array references">Hash Array References</A></H2>
<P>Members of hash arrays are accessed by specifying the hash reference
and key separated by the dot '.' operator.</P>
<PRE>
    my $vars = {
        'home' =&gt; '<A HREF="http://www.myserver.com/homepage.html">http://www.myserver.com/homepage.html</A>',
        'page' =&gt; {
            'this' =&gt; 'mypage.html',
            'next' =&gt; 'nextpage.html',
            'prev' =&gt; 'prevpage.html',
        },
    };
</PRE>
<PRE>

template:</PRE>
<PRE>
    &lt;a href=&quot;[% home %]&quot;&gt;Home&lt;/a&gt;
    &lt;a href=&quot;[% page.prev %]&quot;&gt;Previous Page&lt;/a&gt;
    &lt;a href=&quot;[% page.next %]&quot;&gt;Next Page&lt;/a&gt;</PRE>
<P>output:</P>
<PRE>
    &lt;a href=&quot;<A HREF="http://www.myserver.com/homepage.html&quot">http://www.myserver.com/homepage.html&quot</A>;&gt;Home&lt;/a&gt;
    &lt;a href=&quot;prevpage.html&quot;&gt;Previous Page&lt;/a&gt;
    &lt;a href=&quot;nextpage.html&quot;&gt;Next Page&lt;/a&gt;</PRE>
<P>Any key in a hash which starts with a '_' or '.' character will be
considered private and cannot be evaluated or updated from within a
template.  The undefined value will be returned for any such variable
accessed which the Template Toolkit will silently ignore (unless the
DEBUG option is enabled).</P>
<PRE>
    my $vars = {
        message =&gt; 'Hello World!',
        _secret =&gt; &quot;On the Internet, no-one knows you're a dog&quot;,
        thing   =&gt; {
             public  =&gt; 123,
            _private =&gt; 456,
           '.hidden' =&gt; 789,
        },
    };</PRE>
<P>template:</P>
<PRE>
    [% message %]               # outputs &quot;Hello World!&quot;
    [% _secret %]               # no output
    [% thing.public %]          # outputs &quot;123&quot;
    [% thing._private %]        # no output
    [% thing..hidden %]         # ERROR: unexpected token (..)</PRE>
<P>To access a hash entry using a key stored in another variable, prefix
the key variable with '$' to have it interpolated before use (see
<A HREF="#variable interpolation">Variable Interpolation</A>).</P>
<PRE>
    [% pagename = 'next' %]
    [% page.$pagename %]       # same as [% page.next %]</PRE>
<P>When you assign to a variable that contains multiple namespace 
elements (i.e. it has one or more '.' characters in the name),
any hashes required to represent intermediate namespaces will be 
created automatically.  In this following example, the 'product' 
variable automatically springs into life as a hash array unless
otherwise defined.</P>
<PRE>
    [% product.id    = 'XYZ-2000' 
       product.desc  = 'Bogon Generator'
       product.price = 666 
    %]
</PRE>
<PRE>

    The [% product.id %] [% product.desc %] 
    costs $[% product.price %].00</PRE>
<P>output:</P>
<PRE>
    The XYZ-2000 Bogon Generator 
    costs $666.00</PRE>
<P>You can use Perl's familiar '{' ... '}' construct to explicitly create
a hash and assign it to a variable.  Note that commas are optional
between key/value pairs and '=' can be used in place of '=&gt;'.</P>
<PRE>
    [% product = {
         id    =&gt; 'XYZ-2000',
         desc  =&gt; 'Bogon Generator',
         price =&gt; 666,
       }
    %]</PRE>
<P>
<H2><A NAME="list references">List References</A></H2>
<P>Items in lists are also accessed by use of the dot operator.</P>
<PRE>
    my $vars = {
        'people' =&gt; [ 'Tom', 'Dick', 'Larry' ],
    };</PRE>
<P>template:</P>
<PRE>
    [% people.0 %]                      # Tom
    [% people.1 %]                      # Dick
    [% people.2 %]                      # Larry</PRE>
<P>The FOREACH directive can be used to iterate through items in a list.</P>
<PRE>
    [% FOREACH person = people %]
    Hello [% person %]
    [% END %]</PRE>
<P>output:</P>
<PRE>
    Hello Tom
    Hello Dick
    Hello Larry</PRE>
<P>Lists can be constructed in-situ using the regular anonymous list
'[' ... ']' construct.  Commas between items are optional.</P>
<PRE>
    [% cols = [ 'red', 'green', 'blue' ] %]</PRE>
<PRE>
    [% FOREACH c = cols %]
       ...</PRE>
<P>or:</P>
<PRE>
    [% FOREACH c = [ 'red', 'green', 'blue' ] %]
       ...</PRE>
<P>You can also create simple numerical sequences using the familiar '..'
operator:</P>
<PRE>
    [% n = [ 1 .. 4 ] %]    # n is [ 1, 2, 3, 4 ]</PRE>
<PRE>
    [% x = 4
       y = 8
       z = [x..y]           # z is [ 4, 5, 6, 7, 8 ]
    %]</PRE>
<P>
<H2><A NAME="subroutines">Subroutines</A></H2>
<P>Template variables can contain references to Perl subroutines.  When
the variable is used, the Template Toolkit will automatically call the
subroutine, passing any additional arguments specified.  The return
value from the subroutine is used as the variable value and inserted
into the document output.</P>
<PRE>
    my $vars = {
        wizard  =&gt; sub { return join(' ', 'Abracadabra!', @_) },
    };</PRE>
<P>template:</P>
<PRE>
    [% wizard %]                        # Abracadabra!
    [% wizard('Hocus Pocus!') %]        # Abracadabra! Hocus Pocus!</PRE>
<P>
<H2><A NAME="objects">Objects</A></H2>
<P>Template variables can also contain references to Perl objects.
Methods are called using the dot operator to specify the method
against the object variable.  Additional arguments can be specified
as with subroutines.</P>
<PRE>
    use CGI;</PRE>
<PRE>
    ...</PRE>
<PRE>
    my $vars = {
        # hard coded CGI params for purpose of example
        cgi  =&gt; CGI-&gt;new('mode=submit&amp;debug=1'),
    };</PRE>
<P>template:</P>
<PRE>
    [% FOREACH p = cgi.param %]         # returns list of param keys
    [% p %] =&gt; [% cgi.param(p) %]       # fetch each param value
    [% END %]</PRE>
<P>output:</P>
<PRE>
    mode =&gt; submit
    debug =&gt; 1</PRE>
<P>Object methods can also be called as lvalues.  That is, they can appear on 
the left side of an assignment.  The method will be called passing the 
assigning value as an argument.</P>
<PRE>
    [% myobj.method = 10 %]</PRE>
<P>equivalent to:</P>
<PRE>
    [% myobj.method(10) %]</PRE>
<P>
<H2><A NAME="parameters and return values">Parameters and Return Values</A></H2>
<P>Subroutines and methods will be passed any arguments specified in the
template.  Any template variables in the argument list will first be
evaluated and their resultant values passed to the code.</P>
<PRE>
    my $vars = {
        mycode =&gt; sub { return 'received ' . join(', ', @_) },
    };</PRE>
<P>template:</P>
<PRE>
    [% foo = 10 %]
    [% mycode(foo, 20) %]               # received 10, 20</PRE>
<P>Named parameters may also be specified.  These are automatically collected
into a single hash array which is passed by reference as the <STRONG>last</STRONG> 
parameter to the sub-routine.  Named parameters can be specified using
either '=&gt;' or '=' and can appear anywhere in the argument list.</P>
<PRE>
    my $vars = {
        myjoin =&gt; \&amp;myjoin,
    };</PRE>
<PRE>
    sub myjoin {
        # look for hash ref as last argument
        my $params = ref $_[-1] eq 'HASH' ? pop : { };
        return join($params-&gt;{ joint } || ' + ', @_);
    }</PRE>
<P>template:</P>
<PRE>
    [% myjoin(10, 20, 30) %]
    [% myjoin(10, 20, 30, joint = ' - ' %]
    [% myjoin(joint =&gt; ' * ', 10, 20, 30 %]</PRE>
<P>output:</P>
<PRE>
    10 + 20 + 30
    10 - 20 - 30
    10 * 20 * 30</PRE>
<P>Parenthesised parameters may be added to any element of a variable,
not just those that are bound to code or object methods.  At present,
parameters will be ignored if the variable isn't ``callable'' but are 
supported for future extensions.  Think of them as ``hints'' to that 
variable, rather than just arguments passed to a function.</P>
<PRE>
    [% r = 'Romeo' %]
    [% r(100, 99, s, t, v) %]           # outputs &quot;Romeo&quot;</PRE>
<P>User code should return a value for the variable it represents. This
can be any of the Perl data types described above: a scalar, or
reference to a list, hash, subroutine or object.  Where code returns a
list of multiple values the items will automatically be folded into a
list reference which can be accessed as per normal.</P>
<PRE>
    my $vars = {
        # either is OK, first is recommended
        items1 =&gt; sub { return [ 'foo', 'bar', 'baz' ] },
        items2 =&gt; sub { return ( 'foo', 'bar', 'baz' ) },
    };</PRE>
<P>template:</P>
<PRE>
    [% FOREACH i = items1 %]
       ...
    [% END %]</PRE>
<PRE>
    [% FOREACH i = items2 %]
       ...
    [% END %]</PRE>
<P>
<H2><A NAME="error handling">Error Handling</A></H2>
<P>Errors can be reported from user code by calling die().  Errors raised
in this way are caught by the Template Toolkit and converted to
structured exceptions which can be handled from within the template.
A reference to the exception object is then available as the 'error'
variable.</P>
<PRE>
    my $vars = {
        barf =&gt; sub { 
            die &quot;a sick error has occured\n&quot;;
        },
    };</PRE>
<P>template:</P>
<PRE>
    [% TRY %]
       [% barf %]           # calls sub which throws error via die()
    [% CATCH %]
       [% error.info %]     # outputs &quot;a sick error has occured\n&quot;
    [% END %]</PRE>
<P>Error messages thrown via <CODE>die()</CODE> are converted to exceptions of type
'undef'.  Exceptions of user-defined types can be thrown by calling
<CODE>die()</CODE> with a reference to a Template::Exception object.</P>
<PRE>
    use Template::Exception;</PRE>
<PRE>
    ...
</PRE>
<PRE>

    my $vars = {
        login =&gt; sub { 
            ...
            die Template::Exception-&gt;new('badpwd',
                                         'password too silly');
        },
    };</PRE>
<P>template:</P>
<PRE>
    [% TRY %]
       [% login %]
    [% CATCH badpwd %]
       Bad password: [% error.info %]
    [% CATCH %]
       Some other '[% error.type %]' error: [% error.info %]
    [% END %]</PRE>
<P>The exception types 'stop' and 'return' are used to implement the 
STOP and RETURN directives.  Throwing an exception as:</P>
<PRE>
    die Template::Exception-&gt;new('stop');</PRE>
<P>has the same effect as the directive:</P>
<PRE>
    [% STOP %]</PRE>
<P>Subroutines and methods can also raise errors by returning a list or
reference to a list containing the undefined value (undef) followed by
an exception object or error message.  This is supported for backwards
compatability with version 1 but may be deprecated in some future
version.</P>
<PRE>
    my $vars = {
        # currently equivalent
        barf =&gt; sub {
            die &quot;I'm sorry Dave, I can't do that&quot;;
        },
        yack =&gt; sub {
            return (undef, &quot;I'm sorry Dave, I can't do that&quot;);
        },
    };</PRE>
<P>
<H2><A NAME="virtual variable methods">Virtual Variable Methods</A></H2>
<P>The Template Toolkit provides virtual methods for manipulating
variable values.  Most of them are analagous to regular Perl functions
of the same names.</P>
<P>The following methods can be called against any scalar value:</P>
<DL>
<DT><STRONG><A NAME="item_defined">defined</A></STRONG><BR>
<DD>
Returns true if the value is defined.
<PRE>
    [% user = get_user(uid) IF uid.defined %]</PRE>
<P></P>
<DT><STRONG><A NAME="item_length">length</A></STRONG><BR>
<DD>
Returns the length of the string representation of the item:
<PRE>
    [% IF password.length &lt; 8 %]
       Password too short, dumbass!
    [% END %]</PRE>
<P></P>
<DT><STRONG><A NAME="item_split">split</A></STRONG><BR>
<DD>
Calls Perl's <A HREF="#item_split"><CODE>split()</CODE></A> function to split a string into a list of
strings.
<PRE>
    [% FOREACH dir = mypath.split(':') %]
       [% dir %]
    [% END %]</PRE>
<P></P></DL>
<P>The following can be called against hash references.</P>
<DL>
<DT><STRONG><A NAME="item_keys%2C_values%2C_each">keys, values, each</A></STRONG><BR>
<DD>
The regular hash operators returning lists of keys, values or both.
Note how we use a '$' prefix on the 'key' variable in this example to
have it interpolated (i.e. replaced with its value) before use.
<PRE>
    [% FOREACH key = product.keys %]
       [% key %] =&gt; [% product.$key %]
    [% END %]</PRE>
<P></P>
<DT><STRONG><A NAME="item_sort%2C_nsort">sort, nsort</A></STRONG><BR>
<DD>
Return a list of the keys, sorted alphabetically (sort) or numerically
(nsort) according to the corresponding values in the hash.
<PRE>
    [% FOREACH n = phones.sort %]
       [% phones.$n %] is [% n %],
    [% END %]</PRE>
<P></P>
<DT><STRONG><A NAME="item_import">import</A></STRONG><BR>
<DD>
The import method can be called on a hash array to import the contents
of another hash array.
<PRE>
    [% hash1 = {
           foo =&gt; 'Foo',
           bar =&gt; 'Bar',
       }
       hash2 = {
           wiz =&gt; 'Wiz',
           woz =&gt; 'Woz',
       }
    %]</PRE>
<PRE>
    [% hash1.import(hash2) %]
    [% hash1.wiz %]                     # Wiz</PRE>
<P>You can also call the <A HREF="#item_import"><CODE>import()</CODE></A> method by itself to import a hash array
into the current namespace hash.</P>
<PRE>
    [% user = { id =&gt; 'lwall', name =&gt; 'Larry Wall' } %]
    [% import(user) %]
    [% id %]: [% name %]                # lwall: Larry Wall</PRE>
<P></P></DL>
<P>The following virtual methods are provided for lists:</P>
<DL>
<DT><STRONG><A NAME="item_first%2C_last">first, last</A></STRONG><BR>
<DD>
Returns the first/last item in the list.  The item is not removed from the 
list.
<PRE>
    [% results.first %] to [% results.last %]</PRE>
<P></P>
<DT><STRONG><A NAME="item_size%2C_max">size, max</A></STRONG><BR>
<DD>
Returns the size of a list (number of elements) and the maximum 
index number (size - 1), respectively.
<PRE>
    [% results.size %] search results matched your query</PRE>
<P></P>
<DT><STRONG><A NAME="item_reverse">reverse</A></STRONG><BR>
<DD>
Returns the items of the list in reverse order.
<PRE>
    [% FOREACH s = scores.reverse %]
       ...
    [% END %]</PRE>
<P></P>
<DT><STRONG><A NAME="item_join">join</A></STRONG><BR>
<DD>
Joins the items in the list into a single string, using Perl's join 
function.
<PRE>
    [% items.join(', ') %]</PRE>
<P></P>
<DT><STRONG>sort, nsort</STRONG><BR>
<DD>
Returns the items in alpha (sort) or numerical (nsort) order.
<PRE>
    [% library = books.sort %]</PRE>
<P>Where the list contains hash array references, a hash key can be 
passed as an argument to specify the sort field.</P>
<PRE>
    [% library = books.sort('author') %]</PRE>
<P></P>
<DT><STRONG><A NAME="item_unshift">unshift(), <CODE>push()</CODE></A></STRONG><BR>
<DD>
Adds an item to the start/end of a list.
<PRE>
    [% mylist.unshift('prev item') %]
    [% mylist.push('next item')    %]</PRE>
<P></P>
<DT><STRONG><A NAME="item_shift">shift(), <CODE>pop()</CODE></A></STRONG><BR>
<DD>
Removes the first/last item from the list and returns it.
<PRE>
    [% first = mylist.shift %]
    [% last  = mylist.pop   %]</PRE>
<P></P></DL>
<P>The following example demonstrates how an empty list ('folk') can be 
populated with formatted strings by using the <CODE>push()</CODE> method in conjunction
with a FOREACH loop.  The resultant list can then be printed using join.</P>
<PRE>
    [% # define some initial data
       people   =&gt; [ 
           { id =&gt; 'tom',   name =&gt; 'Tom'     },
           { id =&gt; 'dick',  name =&gt; 'Richard' },
           { id =&gt; 'larry', name =&gt; 'Larry'   },
       ]</PRE>
<PRE>
       # define an empty list that list methods can be called against
       folk = [] 
    -%]</PRE>
<PRE>
    [% folk.push(&quot;&lt;a href=\&quot;${person.id}.html\&quot;&gt;$person.name&lt;/a&gt;&quot;)
         FOREACH person = people.sort('name') -%]
    [% folk.join(&quot;,\n&quot;) %]</PRE>
<P>Output:</P>
<PRE>
    &lt;a href=&quot;larry.html&quot;&gt;Larry&lt;/a&gt;,
    &lt;a href=&quot;dick.html&quot;&gt;Richard&lt;/a&gt;,
    &lt;a href=&quot;tom.html&quot;&gt;Tom&lt;/a&gt;</PRE>
<P>You can define your own virtual methods for scalars, lists and hash
arrays.  The Template::Stash package variables $SCALAR_OPS, $LIST_OPS
and $HASH_OPS are references to hash arrays that define these virtual
methods.  HASH_OPS and LIST_OPS methods are subroutines that accept a
hash/list reference as the first item.  SCALAR_OPS are subroutines
that accept a scalar value as the first item.  Any other arguments
specified when the method is called will be passed to the subroutine.</P>
<PRE>
    # load Template::Stash to make method tables visible
    use Template::Stash;</PRE>
<PRE>
    # define list method to return new list of odd numbers only
    $Template::Stash::LIST_OPS-&gt;{ odd } = sub {
        my $list = shift;
        return [ grep { $_ % 2 } @$list ];
    };</PRE>
<P>template:</P>
<PRE>
    [% primes = [ 2, 3, 5, 7, 9 %] %]
    [% primes.odd.join(', ') %]         # 3, 5, 7, 9</PRE>
<P>See also the examples in the t/vmeth.t test script.</P>
<P>
<H2><A NAME="compound variables">Compound Variables</A></H2>
<P>Compound 'dotted' variables may contain any number of separate
elements.  Each element may evaluate to any of the permitted variable
types and the processor will then correctly use this value to evaluate
the rest of the variable.  Arguments may be passed to any of the
intermediate elements.</P>
<PRE>
    [% myorg.people.sort('surname').first.fullname %]</PRE>
<P>Intermediate variables may be used and will behave entirely as expected.</P>
<PRE>
    [% sorted = myorg.people.sort('surname') %]
    [% sorted.first.fullname %]</PRE>
<P>This simplified dotted notation has the benefit of hiding the
implementation details of your data.  For example, you could implement
a data structure as a hash array one day and then change it to an
object the next without requiring any change to the templates.</P>
<P>
<H2><A NAME="variable interpolation">Variable Interpolation</A></H2>
<P>The Template Toolkit uses '$' consistently to indicate that a variable
should be interpolated in position.  Most frequently, you see this in 
double-quoted strings:</P>
<PRE>
    [% fullname = &quot;$honorific $firstname $surname&quot; %]</PRE>
<P>Or embedded in plain text when the INTERPOLATE option is set:</P>
<PRE>
    Dear $honorific $firstname $surname,</PRE>
<P>The same rules apply within directives.  If a variable is prefixed
with a '$' then it is replaced with its value before being used.  The
most common use is to retrieve an element from a hash where the key is
stored in a variable.</P>
<PRE>
    [% uid = 'abw' %]
    [% userlist.$uid %]             # same as 'userlist.abw'</PRE>
<P>Curly braces can be used to delimit interpolated variable names where
necessary.</P>
<PRE>
    [% userlist.${me.id}.name %]</PRE>
<P>Directives such as INCLUDE, PROCESS, etc., that accept a template name
as the first argument, will automatically quote it for convenience.</P>
<PRE>
    [% INCLUDE foo/bar.txt %]</PRE>
<P>equivalent to:</P>
<PRE>
    [% INCLUDE &quot;foo/bar.txt&quot; %]</PRE>
<P>To INCLUDE a template whose name is stored in a variable, simply
prefix the variable name with '$' to have it interpolated.</P>
<PRE>
    [% myfile = 'header' %]
    [% INCLUDE $myfile %]</PRE>
<P>equivalent to:</P>
<PRE>
    [% INCLUDE header %]</PRE>
<P>Note also that a variable containing a reference to a Template::Document
object can also be processed in this way.</P>
<PRE>
    my $vars = {
        header =&gt; Template::Document-&gt;new({ ... }),
    };</PRE>
<P>template:</P>
<PRE>
    [% INCLUDE $header %]</PRE>
<P>
<H2><A NAME="local and global variables">Local and Global Variables</A></H2>
<P>Any simple variables that you create, or any changes you make to
existing variables, will only persist while the template is being
processed.  The top-level variable hash is copied before processing
begins and any changes to variables are made in this copy, leaving the
original intact.  The same thing happens when you INCLUDE another
template.  The current namespace hash is cloned to prevent any
variable changes made in the included template from interfering with
existing variables.  The PROCESS option bypasses the localisation step
altogether making it slightly faster, but requiring greater attention
to the possibility of side effects caused by creating or changing any
variables within the processed template.</P>
<PRE>
    [% BLOCK change_name %]
       [% name = 'bar' %]
    [% END %]</PRE>
<PRE>
    [% name = 'foo' %] 
    [% INCLUDE change_name %]
    [% name %]                      # foo
    [% PROCESS change_name %]
    [% name %]                      # bar</PRE>
<P>Dotted compound variables behave slightly differently because the
localisation process is only skin deep.  The current variable
namespace hash is copied, but no attempt is made to perform a
deep-copy of other structures within it (hashes, arrays, objects,
etc).  A variable referencing a hash, for example, will be copied to
create a new reference but which points to the same hash.  Thus, the
general rule is that simple variables (undotted variables) are
localised, but existing complex structures (dotted variables) are not.</P>
<PRE>
    [% BLOCK all_change %]
       [% x = 20 %]                 # changes copy
       [% y.z = 'zulu' %]           # changes original
    [% END %]</PRE>
<PRE>
    [% x = 10
       y = { z =&gt; 'zebra' }
    %]
    [% INCLUDE all_change %]
    [% x %]                         # still '10'
    [% y.z %]                       # now 'zulu'</PRE>
<P>If you create a complex structure such as a hash or list reference
within a local template context then it will cease to exist when 
the template is finished processing.</P>
<PRE>
    [% BLOCK new_stuff %]
       [% # define a new 'y' hash array in local context
          y = { z =&gt; 'zulu' }
       %]
    [% END %]</PRE>
<PRE>
    [% x = 10 %]
    [% INCLUDE new_stuff %]
    [% x %]                         # outputs '10'
    [% y %]                         # nothing, y is undefined</PRE>
<P>Similarly, if you update an element of a compound variable which
<EM>doesn't</EM> already exists then a hash will be created automatically
and deleted again at the end of the block.</P>
<PRE>
    [% BLOCK new_stuff %]
       [% y.z = 'zulu' %]
    [% END %]</PRE>
<P>However, if the hash <EM>does</EM> already exist then you will modify the
original with permanent effect.  To avoid potential confusion, it is
recommended that you don't update elements of complex variables from
within blocks or templates included by another.</P>
<P>If you want to create or update truly global variables then you can 
use the 'global' namespace.  This is a hash array automatically created
in the top-level namespace which all templates, localised or otherwise
see the same reference to.  Changes made to variables within this
hash are visible across all templates.</P>
<PRE>
    [% global.version = 123 %]</PRE>
<P>
<H2><A NAME="special variables">Special Variables</A></H2>
<P>A number of special variables are automatically defined by the Template 
Toolkit.</P>
<DL>
<DT><STRONG><A NAME="item_template">template</A></STRONG><BR>
<DD>
The 'template' variable contains a reference to the main template
being processed, in the form of a Template::Document object.  This
variable is correctly defined within PRE_PROCESS, PROCESS and
POST_PROCESS templates, allowing standard headers, footers, etc., to
access metadata items from the main template.  The 'name' and
'modtime' metadata items are automatically provided, giving the
template name and modification time in seconds since the epoch.
<P>Note that the 'template' variable always references the top-level
template, even when processing other template components via INCLUDE,
PROCESS, etc.</P>
<P></P>
<DT><STRONG><A NAME="item_component">component</A></STRONG><BR>
<DD>
The 'component' variable is like 'template' but always contains a
reference to the current, innermost template component being processed.
In the main template, the 'template' and 'component' variable will 
reference the same Template::Document object.  In any other template
component called from the main template, the 'template' variable 
will remain unchanged, but 'component' will contain a new reference
to the current component.
<P>This example should demonstrate the difference:</P>
<PRE>
    $template-&gt;process('foo')
        || die $template-&gt;error(), &quot;\n&quot;;</PRE>
<P>'foo':</P>
<PRE>
    [% template.name %]             # foo
    [% component.name %]            # foo
    [% PROCESS footer %]</PRE>
<P>'footer':</P>
<PRE>
    [% template.name %]             # foo
    [% component.name %]            # footer</PRE>
<P></P>
<DT><STRONG><A NAME="item_loop">loop</A></STRONG><BR>
<DD>
Within a FOREACH loop, the 'loop' variable references the Template::Iterator
object responsible for controlling the loop.
<PRE>
    [% FOREACH item = [ 'foo', 'bar', 'baz' ] -%]
       [% &quot;Items:\n&quot; IF loop.first -%]
       [% loop.count %]/[% loop.size %]: [% item %]
    [% END %]</PRE>
<P></P>
<DT><STRONG><A NAME="item_error">error</A></STRONG><BR>
<DD>
Within a CATCH block, the 'error' variable contains a reference to the 
Template::Exception object thrown from within the TRY block.  The 
'type' and 'info' methods can be called or the variable itself can 
be printed for automatic stringification into a message of the form
``$type error - $info''.  See <A >the Template::Exception manpage</A> for further details.
<PRE>
    [% TRY %]
       ...
    [% CATCH %]
       [% error %]
    [% END %]</PRE>
<P></P>
<DT><STRONG><A NAME="item_content">content</A></STRONG><BR>
<DD>
The WRAPPER method captures the output from a template block and then 
includes a named template, passing the captured output as the 'content'
variable.
<PRE>
    [% WRAPPER box %]
    Be not afeard; the isle is full of noises,
    Sounds and sweet airs, that give delight and hurt not.
    [% END %]</PRE>
<PRE>
    [% BLOCK box %]
    &lt;table border=1&gt;
    &lt;tr&gt;
      &lt;td&gt;
      [% content %]
      &lt;/td&gt;
    &lt;/tr&gt;
    &lt;/table&gt;
    [% END %]</PRE>
<P></P></DL>
<P>
<HR>
<H1><A NAME="template directives">TEMPLATE DIRECTIVES</A></H1>
<P>
<H2><A NAME="accessing and updating template variables">Accessing and Updating Template Variables</A></H2>
<DL>
<DT><STRONG><A NAME="item_GET">GET</A></STRONG><BR>
<DD>
The GET directive retrieves and outputs the value of the named variable.
<PRE>
    [% GET foo %]</PRE>
<P>The GET keyword is optional.  A variable can be specified in a directive
tag by itself.</P>
<PRE>
    [% foo %]</PRE>
<P>The variable may take any of the forms described above:</P>
<PRE>
    [% foo %]
    [% bar.baz %]
    [% biz.baz(10) %]
    ...etc...</PRE>
<P>You can also specify expressions using the logical (and, or, not, ?:) and
mathematic operators (+ - * / % mod div).</P>
<PRE>
    [% template.title or default.title %]</PRE>
<PRE>
    [% score * 100 %]</PRE>
<PRE>
    [% order.nitems ? checkout(order.total) : 'no items' %]</PRE>
<P>The 'div' operator returns the integer result of division.  Both '%' and 
'mod' return the modulus (i.e. remainder) of division.  'mod' is provided
as an alias for '%' for backwards compatability with version 1.</P>
<PRE>
    [% 15 / 6 %]            # 2.5
    [% 15 div 6 %]          # 2
    [% 15 mod 6 %]          # 3</PRE>
<P></P>
<DT><STRONG><A NAME="item_CALL">CALL</A></STRONG><BR>
<DD>
The CALL directive is similar to GET in evaluating the variable named,
but doesn't print the result returned.  This can be useful when a
variable is bound to a sub-routine or object method which you want to
call but aren't interested in the value returned.
<PRE>
    [% CALL dbi.disconnect %]</PRE>
<PRE>
    [% CALL inc_page_counter(page_count) %]</PRE>
<P></P>
<DT><STRONG><A NAME="item_SET">SET</A></STRONG><BR>
<DD>
The SET directive allows you to assign new values to existing variables
or create new temporary variables.
<PRE>
    [% SET title = 'Hello World' %]</PRE>
<P>The SET keyword is also optional.
</P>
<PRE>

    [% title = 'Hello World' %]</PRE>
<P>Variables may be assigned the values of other variables, unquoted
numbers (digits), literal text ('single quotes') or quoted text
(``double quotes'').  In the latter case, any variable references within
the text will be interpolated when the string is evaluated.  Variables
should be prefixed by '$', using curly braces to explicitly scope
the variable name where necessary.</P>
<PRE>
    [% foo  = 'Foo'  %]               # literal value 'Foo'
    [% bar  =  foo   %]               # value of variable 'foo'
    [% cost = '$100' %]               # literal value '$100'
    [% item = &quot;$bar: ${cost}.00&quot; %]   # value &quot;Foo: $100.00&quot;</PRE>
<P>Multiple variables may be assigned in the same directive and are 
evaluated in the order specified.  Thus, the above could have been 
written:</P>
<PRE>
    [% foo  = 'Foo'
       bar  = foo
       cost = '$100'
       item = &quot;$bar: ${cost}.00&quot;
    %]</PRE>
<P>Simple expressions can also be used, as per GET.</P>
<PRE>
    [% ten    = 10 
       twenty = 20
       thirty = twenty + ten
       forty  = 2 * twenty 
       fifty  = 100 div 2
       six    = twenty mod 7
    %]</PRE>
<P></P>
<DT><STRONG><A NAME="item_DEFAULT">DEFAULT</A></STRONG><BR>
<DD>
The DEFAULT directive is similar to SET but only updates variables 
that are currently undefined or have no ``true'' value (in the Perl
sense).
<PRE>
    [% DEFAULT
       name = 'John Doe'
       id   = 'jdoe'
    %]</PRE>
<P>This can be particularly useful in common template components to
ensure that some sensible default are provided for otherwise 
undefined variables.</P>
<PRE>
    [% DEFAULT 
       title = 'Hello World'
       bgcol = '#ffffff'
    %]
    &lt;html&gt;
    &lt;head&gt;
    &lt;title&gt;[% title %]&lt;/title&gt;
    &lt;/head&gt;</PRE>
<PRE>
    &lt;body bgcolor=&quot;[% bgcol %]&quot;&gt;</PRE>
<P></P></DL>
<P>
<H2><A NAME="processing other template files and blocks">Processing Other Template Files and Blocks</A></H2>
<DL>
<DT><STRONG><A NAME="item_INSERT">INSERT</A></STRONG><BR>
<DD>
The INSERT directive is used to insert the contents of an external file
at the current position.
<PRE>
    [% INSERT myfile %]</PRE>
<P>No attempt to parse or process the file is made.  The contents,
possibly including any embedded template directives, are inserted
intact.</P>
<P>The filename specified should be relative to one of the INCLUDE_PATH
directories.  Absolute (i.e. starting with <CODE>/</CODE>) and relative
(i.e. starting with <CODE>.</CODE>) filenames may be used if the ABSOLUTE and
RELATIVE options are set, respectively.  Both these options are
disabled by default.</P>
<PRE>
    my $template = Template-&gt;new({
        INCLUDE_PATH =&gt; '/here:/there',
    });</PRE>
<PRE>
    $template-&gt;process('myfile');</PRE>
<P>'myfile':</P>
<PRE>
    [% INSERT foo %]            # looks for /here/foo then /there/foo
    [% INSERT /etc/passwd %]    # file error: ABSOLUTE not set
    [% INSERT ../secret %]      # file error: RELATIVE not set</PRE>
<P>For convenience, the filename does not need to be quoted as long as it
contains only alphanumeric characters, underscores, dots or forward
slashes.  Names containing any other characters should be quoted.</P>
<PRE>
    [% INSERT misc/legalese.txt            %]
    [% INSERT 'dos98/Program Files/stupid' %]</PRE>
<P>To evaluate a variable to specify a filename, you should explicitly
prefix it with a '$' or use double-quoted string interpolation.</P>
<PRE>
    [% language = 'en'
       legalese = 'misc/legalese.txt' 
    %]</PRE>
<PRE>
    [% INSERT $legalese %]              # 'misc/legalese.txt'
    [% INSERT &quot;$language/$legalese&quot; %]  # 'en/misc/legalese.txt'</PRE>
<P></P>
<DT><STRONG><A NAME="item_INCLUDE">INCLUDE</A></STRONG><BR>
<DD>
The INCLUDE directive is used to process and include the output of
another template file or block.
<PRE>
    [% INCLUDE header %]</PRE>
<P>If a BLOCK of the specified name is defined in the same file, or in a file 
from which the current template has been called (i.e. a parent template) 
then it will be used in preference to any file of the same name.</P>
<PRE>
    [% INCLUDE table %]             # uses BLOCK defined below</PRE>
<PRE>
    [% BLOCK table %]
       &lt;table&gt;
       ...
       &lt;/table&gt;
    [% END %]</PRE>
<P>If a BLOCK definition is not currently visible then the template name
should be a file relative to one of the INCLUDE_PATH directories, or
an absolute or relative file name if the ABSOLUTE/RELATIVE options are
appropriately enabled.  The INCLUDE directive automatically quotes the
filename specified, as per INSERT described above.  When a variable
contains the name of the template for the INCLUDE directive, it should
be explicitly prefixed by '$'.</P>
<PRE>
    [% myheader = 'my/misc/header' %]
    [% INCLUDE  myheader %]              # 'myheader'
    [% INCLUDE $myheader %]              # 'my/misc/header'</PRE>
<P>Any template directives embedded within the file will be processed
accordingly.  All variables currently defined will be visible and 
accessible from within the included template.</P>
<PRE>
    [% title = 'Hello World' %]
    [% INCLUDE header %]
    &lt;body&gt;
    ...</PRE>
<P>'header':
    &lt;html&gt;
    &lt;title&gt;[% title %]&lt;/title&gt;</P>
<P>output:
    &lt;html&gt;
    &lt;title&gt;Hello World&lt;/title&gt;
    &lt;body&gt;
    ...</P>
<P>Local variable definitions may be specified after the template name,
temporarily masking any existing variables.  Insignificant whitespace
is ignore within directives so you can add variable definitions on the
same line, the next line or split across several line with comments
interspersed, if you prefer.</P>
<PRE>
    [% INCLUDE table %]</PRE>
<PRE>
    [% INCLUDE table title=&quot;Active Projects&quot; %]</PRE>
<PRE>
    [% INCLUDE table 
         title   = &quot;Active Projects&quot; 
         bgcolor = &quot;#80ff00&quot;    # chartreuse
         border  = 2
    %]</PRE>
<P>The INCLUDE directive localises (i.e. copies) all variables before
processing the template.  Any changes made within the included
template will not affect variables in the including template.</P>
<PRE>
    [% foo = 10 %]</PRE>
<PRE>
    foo is originally [% foo %]
    [% INCLUDE bar %]
    foo is still [% foo %]</PRE>
<PRE>
    [% BLOCK bar %]
       foo was [% foo %]
       [% foo = 20 %]
       foo is now [% foo %]
    [% END %]</PRE>
<P>output:
    foo is originally 10
       foo was 10
       foo is now 20
    foo is still 10</P>
<P>Technical Note: the localisation of the stash (that is, the process by
which variables are copied before an INCLUDE to prevent being
overwritten) is only skin deep.  The top-level variable namespace
(hash) is copied, but no attempt is made to perform a deep-copy of
other structures (hashes, arrays, objects, etc.)  Therefore, a 'foo'
variable referencing a hash will be copied to create a new 'foo'
variable but which points to the same hash array.  Thus, if you update
compound variables (e.g. foo.bar) then you will change the original
copy, regardless of any stash localisation.  If you're not worried
about preserving variable values, or you trust the templates you're
including then you might prefer to use the PROCESS directive which is
faster by virtue of not performing any localisation.</P>
<P></P>
<DT><STRONG><A NAME="item_PROCESS">PROCESS</A></STRONG><BR>
<DD>
The PROCESS directive is similar to INCLUDE but does not perform any 
localisation of variables before processing the template.  Any changes
made to variables within the included template will be visible in the
including template.
<PRE>
    [% foo = 10 %]</PRE>
<PRE>
    foo is [% foo %]
    [% PROCESS bar %]
    foo is [% foo %]</PRE>
<PRE>
    [% BLOCK bar %]
       [% foo = 20 %]
       changed foo to [% foo %]
    [% END %]</PRE>
<P>output:</P>
<PRE>
    foo is 10
       changed foo to 20
    foo is 20</PRE>
<P>Parameters may be specified in the PROCESS directive, but these too will 
become visible changes to current variable values.</P>
<PRE>
    [% foo = 10 %]
    foo is [% foo %]
    [% PROCESS bar
       foo = 20 
    %]
    foo is [% foo %]</PRE>
<PRE>
    [% BLOCK bar %]
       this is bar, foo is [% foo %]
    [% END %]</PRE>
<P>output:</P>
<PRE>
    foo is 10
       this is bar, foo is 20
    foo is 20</PRE>
<P>The PROCESS directive is slightly faster than INCLUDE because it
avoids the need to localise (i.e. copy) the variable stash before
processing the template.  As with INSERT and INCLUDE, the first
parameter does not need to be quoted as long as it contains only
alphanumeric characters, underscores, periods or forward slashes.
A '$' prefix can be used to explicitly indicate a variable which 
should be interpolated to provide the template name:</P>
<PRE>
    [% myheader = 'my/misc/header' %]
    [% PROCESS  myheader %]              # 'myheader'
    [% PROCESS $myheader %]              # 'my/misc/header'</PRE>
<P></P>
<DT><STRONG><A NAME="item_WRAPPER">WRAPPER</A></STRONG><BR>
<DD>
It's not unusual to find yourself adding common headers and footers to 
pages or sub-sections within a page.  Something like this:
<PRE>
    [% INCLUDE section/header
       title = 'Quantum Mechanics'
    %]
       Quantum mechanics is a very interesting subject wish 
       should prove easy for the layman to fully comprehend.
    [% INCLUDE section/footer %]</PRE>
<PRE>
    [% INCLUDE section/header
       title = 'Desktop Nuclear Fusion for under $50'
    %]
       This describes a simple device which generates significant 
       sustainable electrical power from common tap water by process 
       of nuclear fusion.
    [% INCLUDE section/footer %]</PRE>
<P>The individual template components being included might look like these:</P>
<P>section/header:
    &lt;p&gt;
    &lt;h2&gt;[% title %]&lt;/h2&gt;</P>
<P>section/footer:
    &lt;/p&gt;</P>
<P>The WRAPPER directive provides a way of simplifying this a little.  It
encloses a block up to a matching END directive, which is first
processed to generate some output.  This is then passed to the named
template file or BLOCK as the 'content' variable.</P>
<PRE>
    [% WRAPPER section
       title = 'Quantum Mechanics'
    %]
       Quantum mechanics is a very interesting subject wish 
       should prove easy for the layman to fully comprehend.
    [% END %]</PRE>
<PRE>
    [% WRAPPER section
       title = 'Desktop Nuclear Fusion for under $50'
    %]
       This describes a simple device which generates significant 
       sustainable electrical power from common tap water by process 
       of nuclear fusion.
    [% END %]</PRE>
<P>The single 'section' template can then be defined as:</P>
<PRE>
    &lt;p&gt;
    &lt;h2&gt;[% title %]&lt;/h2&gt;
    [% content %]
    &lt;/p&gt;</PRE>
<P>Like other block directives, it can be used in side-effect notation:</P>
<PRE>
    [% INSERT legalese.txt WRAPPER big_bold_table %]</PRE>
<P></P>
<DT><STRONG><A NAME="item_BLOCK">BLOCK</A></STRONG><BR>
<DD>
The BLOCK ... END construct can be used to define template component
blocks which can be processed with the INCLUDE, PROCESS and WRAPPER
directives.
<PRE>
    [% BLOCK tabrow %]
    &lt;tr&gt;&lt;td&gt;[% name %]&lt;td&gt;&lt;td&gt;[% email %]&lt;/td&gt;&lt;/tr&gt;
    [% END %]
</PRE>
<PRE>

    &lt;table&gt;
    [% PROCESS tabrow  name='Fred'  email='fred@nowhere.com' %]
    [% PROCESS tabrow  name='Alan'  email='alan@nowhere.com' %]
    &lt;/table&gt;</PRE>
<P>A BLOCK definition can be used before it is defined, as long as the
definition resides in the same file.  The block definition itself does
not generate any output.</P>
<PRE>
    [% PROCESS tmpblk %]</PRE>
<PRE>
    [% BLOCK tmpblk %] This is OK [% END %]</PRE>
<P>You can use an anonymous BLOCK to capture the output of a template
fragment.</P>
<PRE>
    [% julius = BLOCK %]
       And Caesar's spirit, ranging for revenge,
       With Ate by his side come hot from hell,
       Shall in these confines with a monarch's voice
       Cry  'Havoc', and let slip the dogs of war;
       That this foul deed shall smell above the earth
       With carrion men, groaning for burial.
    [% END %]</PRE>
<P>Like a named block, it can contain any other template directives which 
are processed when the block is defined.  The output generated by the 
block is then assigned to the variable 'julius'.</P>
<P>Anonymous BLOCKs can also be used to define block macros.  The
enclosing block is processed each time the macro is called.</P>
<PRE>
    [% MACRO whereabouts BLOCK %]
       The [% animal %] sat on the [% place %].
    [% END %]</PRE>
<PRE>
    [% foo(animal='cat', place='mat') %]    # The cat sat on the mat
    [% foo(animal='dog', place='log') %]    # The dog sat on the log</PRE>
<P></P></DL>
<P>
<H2><A NAME="conditional processing">Conditional Processing</A></H2>
<DL>
<DT><STRONG><A NAME="item_IF_%2F_UNLESS_%2F_ELSIF_%2F_ELSE">IF / UNLESS / ELSIF / ELSE</A></STRONG><BR>
<DD>
The IF and UNLESS directives can be used to process or ignore a
block based on some run-time condition.
<PRE>
    [% IF frames %]
       [% INCLUDE frameset %]
    [% END %]</PRE>
<PRE>
    [% UNLESS text_mode %]
       [% INCLUDE biglogo %]
    [% END %]</PRE>
<P>Multiple conditions may be joined with ELSIF and/or ELSE blocks.</P>
<PRE>
    [% IF age &lt; 10 %]
       Hello [% name %], does your mother know you're 
       using her AOL account?
    [% ELSIF age &lt; 18 %]
       Sorry, you're not old enough to enter 
       (and too dumb to lie about your age)
    [% ELSE %]
       Welcome [% name %].
    [% END %]</PRE>
<P>The following conditional and boolean operators may be used:</P>
<PRE>
    == != &lt; &lt;= &gt; &gt;= ! &amp;&amp; || and or not</PRE>
<P>Conditions may be arbitrarily complex and are evaluated with the same
precedence as in Perl.  Parenthesis may be used to explicitly
determine evaluation order.</P>
<PRE>
    # ridiculously contrived complex example
    [% IF (name == 'admin' || uid &lt;= 0) &amp;&amp; mode == 'debug' %]
       I'm confused.
    [% ELSIF more &gt; less %]
       That's more or less correct.
    [% END %]</PRE>
<P></P>
<DT><STRONG><A NAME="item_SWITCH_%2F_CASE">SWITCH / CASE</A></STRONG><BR>
<DD>
The SWITCH / CASE construct can be used to perform a multi-way
conditional test.  The SWITCH directive expects an expression which is
first evaluated and then compared against each CASE statement in turn.
Each CASE directive should contain a single value or a list of values
which should match.  CASE may also be left blank or written as [% CASE
DEFAULT %] to specify a default match.  Only one CASE matches, there
is no drop-through between CASE statements.

<PRE>

    [% SWITCH myvar %]
    [% CASE value1 %]
       ...
    [% CASE [ value2 value3 ] %]   # multiple values
       ...
    [% CASE myhash.keys %]         # ditto
       ...
    [% CASE %]                     # default
       ...
    [% END %]</PRE>
<P></P></DL>
<P>
<H2><A NAME="loop processing">Loop Processing</A></H2>
<DL>
<DT><STRONG><A NAME="item_FOREACH">FOREACH</A></STRONG><BR>
<DD>
The FOREACH directive will iterate through the items in a list, processing
the enclosed block for each one.
<PRE>
    my $vars = {
        foo   =&gt; 'Foo',
        items =&gt; [ 'one', 'two', 'three' ],
    };
</PRE>
<PRE>

template:</PRE>
<PRE>
    Things:
    [% FOREACH thing = [ foo 'Bar' &quot;$foo Baz&quot; ] %]
       * [% thing %]
    [% END %]
</PRE>
<PRE>

    Items:
    [% FOREACH i = items %]
       * [% i %]
    [% END %]</PRE>
<PRE>

    Stuff:
    [% stuff = [ foo &quot;$foo Bar&quot; ] %]
    [% FOREACH s = stuff %]
       * [% s %]
    [% END %]</PRE>
<P>output:</P>
<PRE>
    Things:
      * Foo
      * Bar
      * Foo Baz
</PRE>
<PRE>

    Items:
      * one
      * two
      * three</PRE>
<PRE>

    Stuff:
      * Foo
      * Foo Bar</PRE>
<P>When the FOREACH directive is used without specifying a target variable, 
any iterated values which are hash references will be automatically 
imported.</P>
<PRE>
    [% userlist = [
          { id =&gt; 'tom',   name =&gt; 'Thomas'  },
          { id =&gt; 'dick',  name =&gt; 'Richard'  },
          { id =&gt; 'larry', name =&gt; 'Lawrence' },
       ]
    %]</PRE>
<PRE>
    [% FOREACH user = userlist %]
       [% user.id %] [% user.name %]
    [% END %]</PRE>
<P>short form:</P>
<PRE>
    [% FOREACH userlist %]
       [% id %] [% name %]
    [% END %]</PRE>
<P>Note that this particular usage creates a localised variable context
to prevent the imported hash keys from overwriting any existing
variables.  The imported definitions and any other variables defined
in such a FOREACH loop will be lost at the end of the loop, when the 
previous context and variable values are restored.</P>
<P>The FOREACH directive can also be used to iterate through the entries
in a hash array.  Each entry in the hash is returned in sorted order
(based on the key) as a hash array containing 'key' and 'value' items.</P>
<PRE>
    [% users = {
         tom   =&gt; 'Thomas',
         dick  =&gt; 'Richard',
         larry =&gt; 'Lawrence',
       }
    %]</PRE>
<PRE>
    [% FOREACH u = users %]
       * [% u.key %] : [% u.value %]
    [% END %]</PRE>
<P>Output:</P>
<PRE>
       * dick : Richard
       * larry : Lawrence
       * tom : Thomas</PRE>
<P>The NEXT directive starts the next iteration in the FOREACH loop.</P>
<PRE>
    [% FOREACH user = userlist %]
       [% NEXT IF user.isguest %]
       Name: [% user.name %]    Email: [% user.email %]
    [% END %]</PRE>
<P>The LAST directive can be used to prematurely exit the loop.  BREAK is
also provided as an alias for LAST.</P>
<PRE>
    [% FOREACH match = results.nsort('score').reverse %]
       [% LAST IF match.score &lt; 50 %]
       [% match.score %] : [% match.url %]
    [% END %]</PRE>
<P>The FOREACH directive is implemented using the Template::Iterator
module.  A reference to the iterator object for a FOREACH directive is
implicitly available in the 'loop' variable.  The following methods 
can be called on the 'loop' iterator.</P>
<PRE>
    size()      number of elements in the list
    max()       index number of last element (size - 1)
    index()     index of current iteration from 0 to max()
    count()     iteration counter from 1 to size() (i.e. index() + 1)
    first()     true if the current iteration is the first
    last()      true if the current iteration is the last
    prev()      return the previous item in the list
    next()      return the next item in the list</PRE>
<P>See <A >the Template::Iterator manpage</A> for further details.</P>
<P>Example:</P>
<PRE>
    [% FOREACH item = [ 'foo', 'bar', 'baz' ] -%]
       [%- &quot;&lt;ul&gt;\n&quot; IF loop.first %]
       &lt;li&gt;[% loop.count %]/[% loop.size %]: [% item %]
       [%- &quot;&lt;/ul&gt;\n&quot; IF loop.last %]
    [% END %]</PRE>
<P>Output:</P>
<PRE>
    &lt;ul&gt;
    &lt;li&gt;1/3: foo
    &lt;li&gt;2/3: bar
    &lt;li&gt;3/3: baz
    &lt;/ul&gt;</PRE>
<P>Note that the <CODE>number()</CODE> method is supported as an alias for <CODE>count()</CODE> for
backwards compatability but may be deprecated in some future version.</P>
<P>Nested loops will work as expected, with the 'loop' variable correctly 
referencing the innermost loop and being restored to any previous 
value (i.e. an outer loop) at the end of the loop.</P>
<PRE>
    [% FOREACH group = grouplist %]
       [% &quot;Groups:\n&quot; IF loop.first %]        # loop =&gt; group iterator
       [% FOREACH user = group.userlist %]
          [% loop.count %]: [% user.name %]   # loop =&gt; user iterator
       [% END %]
       [% &quot;End of Groups\n&quot; IF loop.last %]   # loop =&gt; group iterator
    [% END %]</PRE>
<P>The 'iterator' plugin can also be used to explicitly create an
iterator object.  This can be useful within nested loops where you
need to keep a reference to the outer iterator within the inner loop.
The iterator plugin effectively allows you to create an iterator by a
name other than 'loop'.  See Template::Plugin::Iterator for further
details.</P>
<PRE>
    [% USE giter = iterator(grouplist) %]</PRE>
<PRE>
    [% FOREACH group = giter %]
       [% FOREACH user = group.userlist %]
       user [% loop.count %] in group [% giter.count %]: [% user.name %]
       [% END %]
    [% END %]</PRE>
<P></P>
<DT><STRONG><A NAME="item_WHILE">WHILE</A></STRONG><BR>
<DD>
The WHILE directive can be used to repeatedly process a template block
while a conditional expression evaluates true.  The expression may 
be arbitrarily complex as per IF / UNLESS.
<PRE>
    [% WHILE total &lt; 100 %]
       ...
       [% total = calculate_new_total %]
    [% END %]</PRE>
<P>An assignment can be enclosed in parenthesis to evaluate the assigned
value.</P>
<PRE>
    [% WHILE (user = get_next_user_record) %]
       [% user.name %]
    [% END %]</PRE>
<P>The NEXT directive can be used to start the next iteration of a 
WHILE loop and BREAK can be used to exit the loop, both as per FOREACH.</P>
<P>The Template Toolkit uses a failsafe counter to prevent runaway WHILE
loops which would otherwise never terminate.  If the loop exceeds 1000
iterations then an 'undef' exception will be thrown, reporting the
error:</P>
<PRE>
    WHILE loop terminated (&gt; 1000 iterations)</PRE>
<P>The $Template::Directive::WHILE_MAX variable controls this behaviour
and can be set to a higher value if necessary.</P>
<P></P></DL>
<P>
<H2><A NAME="filters, plugins, macros and perl">Filters, Plugins, Macros and Perl</A></H2>
<DL>
<DT><STRONG><A NAME="item_FILTER">FILTER</A></STRONG><BR>
<DD>
The FILTER directive can be used to post-process the output of a
block.  A number of standard filters are provided with the Template
Toolkit.  The 'html' filter, for example, escapes the '&lt;', '&gt;'
and '&amp;' characters to prevent them from being interpreted as HTML tags
or entity reference markers.
<PRE>
    [% FILTER html %]
       HTML text may have &lt; and &gt; characters embedded
       which you want converted to the correct HTML entities.
    [% END %]</PRE>
<P>output:</P>
<PRE>
       HTML text may have &amp;lt; and &amp;gt; characters embedded
       which you want converted to the correct HTML entities.</PRE>
<P>The FILTER directive can also follow various other non-block directives.
For example:</P>
<PRE>
    [% INCLUDE mytext FILTER html %]</PRE>
<P>The '|' character can also be used as an alias for 'FILTER'.</P>
<PRE>
    [% INCLUDE mytext | html %]</PRE>
<P>Multiple filters can be chained together and will be called in sequence.</P>
<PRE>
    [% INCLUDE mytext FILTER html FILTER html_para %]</PRE>
<P>or</P>
<PRE>
    [% INCLUDE mytext | html | html_para %]</PRE>
<P>Filters come in two flavours, known as 'static' or 'dynamic'.  A
static filter is a simple subroutine which accepts a text string as
the only argument and returns the modified text.  The 'html' filter is
an example of a static filter, implemented as:</P>
<PRE>
    sub html_filter {
        my $text = shift;
        for ($text) {
            s/&amp;/&amp;amp;/g;
            s/&lt;/&amp;lt;/g;
            s/&gt;/&amp;gt;/g;
        }
        return $text;
    }</PRE>
<P>Dynamic filters can accept arguments which are specified when the filter
is called from a template.  The 'repeat' filter is such an example, 
accepting a numerical argument which specifies the number of times
that the input text should be repeated.</P>
<PRE>
    [% FILTER repeat(3) %]blah [% END %]</PRE>
<P>output:</P>
<PRE>
    blah blah blah</PRE>
<P>These are implemented as filter 'factories'.  The factory subroutine
is passed a reference to the current Template::Context object along
with any additional arguments specified.  It should then return a
subroutine reference (e.g. a closure) which implements the filter.
The 'repeat' filter factory is implemented like this:</P>
<PRE>
    sub repeat_filter_factory {
        my ($context, $iter) = @_;
        $iter = 1 unless defined $iter;</PRE>
<PRE>
        return sub {
            my $text = shift;
            $text = '' unless defined $text;
            return join('\n', $text) x $iter;
        }
    }</PRE>
<P>The FILTERS option, described in <A HREF="#configuration options">CONFIGURATION OPTIONS</A>, allows 
custom filters to be defined when a Template object is instantiated.  
The Template::Context <CODE>define_filter()</CODE> method allows further filters
to be defined at any time.</P>
<P>When using a filter, it is possible to assign an alias to it for 
further use.  This is most useful for dynamic filters that you want 
to re-use with the same configuration.</P>
<PRE>
    [% FILTER echo = repeat(2) %]
    Is there anybody out there?
    [% END %]</PRE>
<PRE>
    [% FILTER echo %]
    Mother, should I build a wall?
    [% END %]</PRE>
<P>Output:</P>
<PRE>
    Is there anybody out there?
    Is there anybody out there?</PRE>
<PRE>
    Mother, should I build a wall?
    Mother, should I build a wall?</PRE>
<P>The FILTER directive automatically quotes the name of the filter.  As
with INCLUDE et al, you can use a variable to provide the name of the 
filter, prefixed by '$'.</P>
<PRE>
    [% myfilter = 'html' %]
    [% FILTER $myfilter %]      # same as [% FILTER html %]
       ...
    [% END %]</PRE>
<P>A template variable can also be used to define a static filter
subroutine.  However, the Template Toolkit will automatically call any
subroutine bound to a variable and use the value returned.  Thus, the
above example could be implemented as:</P>
<PRE>
    my $vars = {
        myfilter =&gt; sub { return 'html' },
    };</PRE>
<P>template:</P>
<PRE>
    [% FILTER $myfilter %]      # same as [% FILTER html %]
       ...
    [% END %]</PRE>
<P>To define a template variable that evaluates to a subroutine reference
that can be used by the FILTER directive, you should create a
subroutine that, when called automatically by the Template Toolkit,
returns another subroutine reference which can then be used to perform
the filter operation.  Note that only static filters can be
implemented in this way.</P>
<PRE>
    my $vars = {
        myfilter =&gt; sub { \&amp;my_filter_sub },
    };</PRE>
<PRE>
    sub my_filter_sub {
        my $text = shift;
        # do something
        return $text;
    }</PRE>
<P>template:</P>
<PRE>
    [% FILTER $myfilter %]
       ...
    [% END %]</PRE>
<P>Alternately, you can bless a subroutine reference into a class (any
class will do) to fool the Template Toolkit into thinking it's an
object rather than a subroutine.  This will then bypass the automatic
``call-a-subroutine-to-return-a-value'' magic.</P>
<PRE>
    my $vars = {
        myfilter =&gt; bless(\&amp;my_filter_sub, 'anything_you_like'),
    };</PRE>
<P>template:</P>
<PRE>
    [% FILTER $myfilter %]          
       ...
    [% END %]</PRE>
<P>Filters bound to template variables remain local to the variable
context in which they are defined.  That is, if you define a filter in
a PERL block within a template that is loaded via INCLUDE, then the
filter definition will only exist until the end of that template when
the stash is delocalised, restoring the previous variable state.  If
you want to define a filter which persists for the lifetime of the
processor, or define additional dynamic filter factories, then you can
call the <CODE>define_filter()</CODE> method on the current Template::Context
object.</P>
<P>See <A HREF="#template toolkit filters">TEMPLATE TOOLKIT FILTERS</A> for a complete list of available filters,
their descriptions and examples of use.</P>
<P></P>
<DT><STRONG><A NAME="item_USE">USE</A></STRONG><BR>
<DD>
The USE directive can be used to load and initialise ``plugin''
extension modules.
<PRE>
    [% USE myplugin %]</PRE>
<P>A plugin is a regular Perl module that conforms to a particular
object-oriented interface, allowing it to be loaded into and used
automatically by the Template Toolkit.  For details of this interface
and information on writing plugins, consult <A >the Template::Plugin manpage</A>.</P>
<P>The plugin name is case-sensitive and will be appended to the
PLUGIN_BASE value (default: 'Template::Plugin') to construct a full
module name.  Any periods, '.', in the name will be converted to '::'.</P>
<PRE>
    [% USE MyPlugin %]     #  =&gt; Template::Plugin::MyPlugin
    [% USE Foo.Bar  %]     #  =&gt; Template::Plugin::Foo::Bar</PRE>
<P>Various standard plugins are included with the Template Toolkit (see 
below and <A HREF="#template toolkit plugins">TEMPLATE TOOLKIT PLUGINS</A>).  These can be specified in lower
case and are mapped to the appropriate name.</P>
<PRE>
    [% USE cgi   %]        # =&gt; Template::Plugin::CGI
    [% USE table %]        # =&gt; Template::Plugin::Table</PRE>
<P>Any additional parameters supplied in parenthesis after the plugin
name will be also be passed to the <CODE>new()</CODE> constructor.  A reference to
the current Template::Context object is always passed as the first
parameter.</P>
<PRE>
    [% USE MyPlugin('foo', 123) %]</PRE>
<P>equivalent to:</P>
<PRE>
    Template::Plugin::MyPlugin-&gt;new($context, 'foo', 123);</PRE>
<P>Named parameters may also be specified.  These are collated into a
hash which is passed by reference as the last parameter to the
constructor, as per the general code calling interface.</P>
<PRE>
    [% USE url('/cgi-bin/foo', mode='submit', debug=1) %]</PRE>
<P>equivalent to:</P>
<PRE>
    Template::Plugin::URL-&gt;new($context, '/cgi-bin/foo'
                               { mode =&gt; 'submit', debug =&gt; 1 });</PRE>
<P>The plugin may represent any data type; a simple variable, hash, list or
code reference, but in the general case it will be an object reference.
Methods can be called on the object (or the relevant members of the
specific data type) in the usual way:</P>
<PRE>
    [% USE table(mydata, rows=3) %]</PRE>
<PRE>
    [% FOREACH row = table.rows %]
       &lt;tr&gt;    
       [% FOREACH item = row %]
          &lt;td&gt;[% item %]&lt;/td&gt;
       [% END %]
       &lt;/tr&gt;
    [% END %]</PRE>
<P>An alternative name may be provided for the plugin by which it can be 
referenced:</P>
<PRE>
    [% USE scores = table(myscores, cols=5) %]</PRE>
<PRE>
    [% FOREACH row = scores.rows %]
       ...
    [% END %]</PRE>
<P>You can use this approach to create multiple plugin objects with
different configurations.  This example shows how the 'format' plugin
is used to create sub-routines bound to variables for formatting text
as per printf().</P>
<PRE>
    [% USE bold = format('&lt;b&gt;%s&lt;/b&gt;') %]
    [% USE ital = format('&lt;i&gt;%s&lt;/i&gt;') %]</PRE>
<PRE>
    [% bold('This is bold')   %]
    [% ital('This is italic') %]</PRE>
<P>Output:</P>
<PRE>
    &lt;b&gt;This is bold&lt;/b&gt;
    &lt;i&gt;This is italic&lt;/i&gt;</PRE>
<P>This next example shows how the URL plugin can be used to build
dynamic URLs from a base part and optional query parameters.</P>
<PRE>
    [% USE mycgi = URL('/cgi-bin/foo.pl', debug=1) %]
    &lt;a href=&quot;[% mycgi %]&quot;&gt;...
    &lt;a href=&quot;[% mycgi(mode='submit') %]&quot;...</PRE>
<P>Output:</P>
<PRE>
    &lt;a href=&quot;/cgi-bin/foo.pl?debug=1&quot;&gt;...
    &lt;a href=&quot;/cgi-bin/foo.pl?mode=submit&amp;debug=1&quot;&gt;...</PRE>
<P>The CGI plugin is an example of one which delegates to another Perl
module.  In this this case, it is to Lincoln Stein's CGI.pm module.
All of the methods provided by CGI.pm are available via the plugin.</P>
<PRE>
    [% USE CGI %]</PRE>
<PRE>
    [% CGI.start_form %]</PRE>
<PRE>
    [% CGI.checkbox_group(name   =&gt;   'colours', 
                          values =&gt; [ 'red' 'green' 'blue' ])
    %]</PRE>
<PRE>
    [% CGI.popup_menu(name   =&gt;   'items', 
                      values =&gt; [ 'foo' 'bar' 'baz' ])
    %]</PRE>
<PRE>
    [% CGI.end_form %]</PRE>
<P>Simon Matthews has written the DBI plugin which provides an interface
to Tim Bunce's DBI module (available from CPAN).  Here's a short
example:</P>
<PRE>
    [% USE DBI('DBI:mSQL:mydbname') %]</PRE>
<PRE>
    [% FOREACH user = DBI.query('SELECT * FROM users') %]
       [% user.id %] [% user.name %] [% user.etc.etc %]
    [% END %]</PRE>
<P>See <A HREF="#template toolkit plugins">TEMPLATE TOOLKIT PLUGINS</A> for more information on the plugins
distributed with the toolkit or available from CPAN.</P>
<P>The LOAD_PERL option (disabled by default) provides a further way by
which external Perl modules may be loaded.  If a regular Perl module
(i.e. not a Template::Plugin::* or other module relative to some
PLUGIN_BASE) supports an object-oriented interface and a <CODE>new()</CODE>
constructor then it can be loaded and instantiated automatically.  The
following trivial example shows how the IO::File module might be used.</P>
<PRE>
    [% USE file = IO.File('/tmp/mydata') %]</PRE>
<PRE>
    [% WHILE (line = file.getline) %]
       &lt;!-- [% line %] --&gt;
    [% END %]</PRE>
<P></P>
<DT><STRONG><A NAME="item_MACRO">MACRO</A></STRONG><BR>
<DD>
The MACRO directive allows you to define a directive or directive block
which is then evaluated each time the macro is called.
<PRE>
    [% MACRO header INCLUDE header %]</PRE>
<P>Calling the macro as:</P>
<PRE>
    [% header %]</PRE>
<P>is then equivalent to:</P>
<PRE>
    [% INCLUDE header %]</PRE>
<P>Macros can be passed named parameters when called.  These values remain 
local to the macro.</P>
<PRE>
    [% header(title='Hello World') %]</PRE>
<P>equivlant to:</P>
<PRE>
    [% INCLUDE header title='Hello World' %]</PRE>
<P>A MACRO definition may include parameter names.  Values passed to the 
macros are then mapped to these local variables.  Other named parameters
may follow these.</P>
<PRE>
    [% MACRO header(title) INCLUDE header %]</PRE>
<PRE>
    [% header('Hello World') %]
    [% header('Hello World', bgcol='#123456') %]</PRE>
<P>equivalent to:</P>
<PRE>
    [% INCLUDE header title='Hello World' %]
    [% INCLUDE header title='Hello World' bgcol='#123456# %]</PRE>
<P>A MACRO may preceed any directive and must conform to the structure 
of the directive.</P>
<PRE>
    [% MACRO header IF frames %]
       [% INCLUDE frames/header %]
    [% ELSE %]
       [% INCLUDE header %]
    [% END %]</PRE>
<PRE>
    [% header %]</PRE>
<P>A MACRO may also be defined as an anonymous BLOCK.  The block will be
evaluated each time the macro is called.</P>
<PRE>
    [% MACRO header BLOCK %]
       ...content...
    [% END %]</PRE>
<PRE>
    [% header %]</PRE>
<P></P>
<DT><STRONG><A NAME="item_PERL">PERL</A></STRONG><BR>
<DD>
The PERL directive is used to mark the start of a block which contains
Perl code for evaluation.  The EVAL_PERL option must be enabled for Perl
code to be evaluated or a 'perl' exception will be thrown with the 
message 'EVAL_PERL not set'.
<P>Perl code is evaluated in the Template::Perl package.  The $context
package variable contains a reference to the current Template::Context
object.  This can be used to access the functionality of the Template
Toolkit to process other templates, load plugins, filters, etc.
See <A >the Template::Context manpage</A> for further details.</P>
<PRE>
    [% PERL %]
       print $context-&gt;include('myfile');
    [% END %]</PRE>
<P>The $stash variable contains a reference to the top-level stash object
which manages template variables.  Through this, variable values can
be retrieved and updated.  See <A >the Template::Stash manpage</A> for further details.</P>
<PRE>
    [% PERL %]
       $stash-&gt;set(foo =&gt; 'bar');
       print &quot;foo value: &quot;, $stash-&gt;get('foo');
    [% END %]</PRE>
<P>Output
    foo value: bar</P>
<P>Output is generated from the PERL block by calling print().  Note that
the Template::Perl::PERLOUT handle is selected (tied to an output
buffer) instead of STDOUT.</P>
<PRE>
    [% PERL %]
       print &quot;foo\n&quot;;                           # OK
       print PERLOUT &quot;bar\n&quot;;                   # OK, same as above
       print Template::Perl::PERLOUT &quot;baz\n&quot;;   # OK, same as above
       print STDOUT &quot;qux\n&quot;;                    # WRONG!
    [% END %]</PRE>
<P>The PERL block may contain other template directives.  These are
processed before the Perl code is evaluated.</P>
<PRE>
    [% name = 'Fred Smith' %]</PRE>
<PRE>
    [% PERL %]
       print &quot;[% name %]\n&quot;;
    [% END %]</PRE>
<P>Thus, the Perl code in the above example is evaluated as:</P>
<PRE>
    print &quot;Fred Smith\n&quot;;</PRE>
<P>Exceptions may be thrown from within PERL blocks via <CODE>die()</CODE> and will be
correctly caught by enclosing TRY blocks.</P>
<PRE>
    [% TRY %]
       [% PERL %]
          die &quot;nothing to live for\n&quot;;
       [% END %]
    [% CATCH %]
       error: [% error.info %]
    [% END %]</PRE>
<P>output:
       error: nothing to live for</P>
<P></P>
<DT><STRONG><A NAME="item_RAWPERL">RAWPERL</A></STRONG><BR>
<DD>
The Template Toolkit parser reads a source template and generates the
text of a Perl subroutine as output.  It then uses <A HREF="#item_eval"><CODE>eval()</CODE></A> to evaluate
it into a subroutine reference.  This subroutine is then called to
process the template, passing a reference to the current
Template::Context object through which the functionality of the
Template Toolkit can be accessed.  The subroutine reference can be
cached, allowing the template to be processed repeatedly without
requiring any further parsing.
<P>For example, a template such as:</P>
<PRE>
    [% PROCESS header %]
    The [% animal %] sat on the [% location %]
    [% PROCESS footer %]</PRE>
<P>is converted into the following Perl subroutine definition:</P>
<PRE>
    sub {
        my $context = shift;
        my $stash   = $context-&gt;stash;
        my $output  = '';
        my $error;
</PRE>
<PRE>

        eval { BLOCK: {
            $output .=  $context-&gt;process('header');
            $output .=  &quot;The &quot;;
            $output .=  $stash-&gt;get('animal');
            $output .=  &quot; sat on the &quot;;
            $output .=  $stash-&gt;get('location');
            $output .=  $context-&gt;process('footer');
            $output .=  &quot;\n&quot;;
        } };
        if ($@) {
            $error = $context-&gt;catch($@, \$output);
            die $error unless $error-&gt;type eq 'return';
        }</PRE>
<PRE>

        return $output;
    }</PRE>
<P>To examine the Perl code generated, such as in the above example, set
the $Template::Parser::DEBUG package variable to any true value.  You
can also set the $Template::Directive::PRETTY variable true to have
the code formatted in a readable manner for human consumption.  The
source code for each generated template subroutine will be printed to
STDERR on compilation (i.e. the first time a template is used).</P>
<PRE>
    $Template::Parser::DEBUG = 1;
    $Template::Directive::PRETTY = 1;</PRE>
<PRE>
    ...</PRE>
<PRE>
    $template-&gt;process($file, $vars)
        || die $template-&gt;error(), &quot;\n&quot;;</PRE>
<P>The PERL ... END construct allows Perl code to be embedded into a
template (when the EVAL_PERL option is set), but it is evaluated at
``runtime'' using <A HREF="#item_eval"><CODE>eval()</CODE></A> each time the template subroutine is called.
This is inherently flexible, but not as efficient as it could be,
especially in a persistant server environment where a template may be
processed many times.</P>
<P>The RAWPERL directive allows you to write Perl code that is integrated
directly into the generated Perl subroutine text.  It is evaluated
once at compile time and is stored in cached form as part of the
compiled template subroutine.  This makes RAWPERL blocks more
efficient than PERL blocks.</P>
<P>The downside is that you must code much closer to the metal.  Within
PERL blocks, you can call <CODE>print()</CODE> to generate some output.  RAWPERL
blocks don't afford such luxury.  The code is inserted directly into
the generated subroutine text and should conform to the convention of
appending to the '$output' variable.</P>
<PRE>
    [% PROCESS  header %]</PRE>
<PRE>
    [% RAWPERL %]
       $output .= &quot;Some output\n&quot;;
       ...
       $output .= &quot;Some more output\n&quot;;
    [% END %]</PRE>
<P>The critical section of the generated subroutine for this example would 
then look something like:</P>
<PRE>
    ...
    eval { BLOCK: {
        $output .=  $context-&gt;process('header');
        $output .=  &quot;\n&quot;;
        $output .= &quot;Some output\n&quot;;
        ...
        $output .= &quot;Some more output\n&quot;;
        $output .=  &quot;\n&quot;;
    } };
    ...</PRE>
<P>As with PERL blocks, the $context and $stash references are pre-defined
and available for use within RAWPERL code.</P>
<P></P></DL>
<P>
<H2><A NAME="exception handling and flow control">Exception Handling and Flow Control</A></H2>
<DL>
<DT><STRONG><A NAME="item_TRY_%2F_THROW_%2F_CATCH_%2F_FINAL">TRY / THROW / CATCH / FINAL</A></STRONG><BR>
<DD>
The Template Toolkit supports fully functional, nested exception
handling.  The TRY directive introduces an exception handling scope 
which continues until the matching END directive.  Any errors that 
occur within that block will be caught and can be handled by one
of the CATCH blocks defined.
<PRE>
    [% TRY %]
       ...blah...blah...
       [% CALL somecode %]
       ...etc...
       [% INCLUDE someblock %]
       ...and so on...
    [% CATCH %]
       An error occurred!
    [% END %]</PRE>
<P>Errors are raised as exceptions (objects of the Template::Exception 
class) and contain two fields, 'type' and 'info'.  The exception 
'type' can be any string containing letters, numbers, '_' or '.', and
is used to indicate the kind of error that occurred.  The 'info' field
contains an error message indicating what actually went wrong.  Within
a catch block, the exception object is aliased to the 'error' variable.
You can access the 'type' and 'info' fields directly.</P>
<PRE>
    [% mydsn = 'dbi:MySQL:foobar' %]
    ...</PRE>
<PRE>
    [% TRY %]
       [% USE DBI(mydsn) %]
    [% CATCH %]
       ERROR! Type: [% error.type %]
              Info: [% error.info %]
    [% END %]</PRE>
<P>output (assuming a non-existant database called 'foobar'):</P>
<PRE>
    ERROR!  Type: DBI
            Info: Unknown database &quot;foobar&quot;</PRE>
<P>The 'error' variable can also be specified by itself and will return a 
string of the form ``$type error - $info''.</P>
<PRE>
    ...
    [% CATCH %]
    ERROR: [% error %]
    [% END %]</PRE>
<P>output:</P>
<PRE>
    ERROR: DBI error - Unknown database &quot;foobar&quot;</PRE>
<P>Each CATCH block may be specified with a particular exception type
denoting the kind of error that it should catch.  Multiple CATCH
blocks can be provided to handle different types of exception that may
be thrown in the TRY block.  A CATCH block specified without any type,
as in the previous example, is a default handler which will catch any
otherwise uncaught exceptions.  This can also be specified as 
[% CATCH DEFAULT %].</P>
<PRE>
    [% TRY %]
       [% INCLUDE myfile %]
       [% USE DBI(mydsn) %]
       [% CALL somecode %]
       ...
    [% CATCH file %]
       File Error! [% error.info %]
    [% CATCH DBI %]
       [% INCLUDE database/error.html %]
    [% CATCH %]
       [% error %]
    [% END %]</PRE>
<P>Remember that you can specify multiple directives within a single tag,
each delimited by ';'.  Thus, you might prefer to write your simple
CATCH blocks more succinctly as:</P>
<PRE>
    [% TRY %]
       ...
    [% CATCH file; &quot;File Error! $error.info&quot; %]
    [% CATCH DBI;  INCLUDE database/error.html %]
    [% CATCH; error %]
    [% END %]</PRE>
<P>or even:</P>
<PRE>
    [% TRY %]
       ...
    [% CATCH file ;
           &quot;File Error! $error.info&quot; ;
       CATCH DBI ;
           INCLUDE database/error.html ;
       CATCH ;
           error ;
       END
    %]</PRE>
<P>The DBI plugin throws exceptions of the 'DBI' type (in case that
wasn't already obvious).  The other specific exception caught here is
of the 'file' type.</P>
<P>A 'file' error is automatically thrown by the Template Toolkit when it
can't find a file, or fails to load, parse or process a file that has
been requested by an INCLUDE, PROCESS, INSERT or WRAPPER directive.
If 'myfile' can't be found in the example above, the [% INCLUDE myfile
%] directive will raise a 'file' exception which is then caught by the
[% CATCH file %] block, generating the output:</P>
<PRE>
    File Error! myfile: not found</PRE>
<P>Note that the DEFAULT option (disabled by default) allows you to
specify a default file to be used any time a template file can't be
found.  This will prevent file exceptions from ever being raised when
a non-existant file is requested (unless, of course, the DEFAULT file
doesn't exist).  Errors encountered once the file has been found
(i.e. read error, parse error) will be raised as file exceptions as per
usual.</P>
<P>Uncaught exceptions (i.e. the TRY block doesn't have a type specific
or default CATCH handler) may be caught by enclosing TRY blocks which
can be nested indefinately across multiple templates.  If the error
isn't caught at any level then processing will stop and the Template
<CODE>process()</CODE> method will return a false value to the caller.  The
relevant Template::Exception object can be retrieved by calling the
<A HREF="#item_error"><CODE>error()</CODE></A> method.</P>
<PRE>
    [% TRY %]
       ...
       [% TRY %]
          [% INCLUDE $user.header %]
       [% CATCH file %]
          [% INCLUDE header %]
       [% END %]
       ...
    [% CATCH DBI %]
       [% INCLUDE database/error.html %]
    [% END %]</PRE>
<P>In this example, the inner TRY block is used to ensure that the first
INCLUDE directive works as expected.  We're using a variable to
provide the name of the template we want to include, user.header, and
it's possible this contains the name of a non-existant template, or
perhaps one containing invalid template directives.  If the INCLUDE fails
 with a 'file' error then we CATCH it in the inner block and INCLUDE
the default 'header' file instead.  Any DBI errors that occur within
the scope of the outer TRY block will be caught in the relevant CATCH
block, causing the 'database/error.html' template to be processed.
Note that included templates inherit all currently defined template
variable so these error files can quite happily access the 'error'
variable to retrieve information about the currently caught exception.
e.g.</P>
<P>'database/error.html':</P>
<PRE>
    &lt;h2&gt;Database Error&lt;/h2&gt;
    A database error has occurred: [% error.info %]</PRE>
<P>You can also specify a FINAL block.  This is always processed
regardless of the outcome of the TRY and/or CATCH block.  If an
exception is uncaught then the FINAL block is processed before jumping
to the enclosing block or returning to the caller.</P>
<PRE>
    [% TRY %]
       ...
    [% CATCH this %] 
       ...
    [% CATCH that %] 
       ...
    [% FINAL %]
       All done!
    [% END %]</PRE>
<P>The output from the TRY block is left intact up to the point where an
exception occurs.  For example, this template:</P>
<PRE>
    [% TRY %]
       This gets printed 
       [% THROW food 'carrots' %]
       This doesn't
    [% CATCH food %]
       culinary delights: [% error.info %]
    [% END %]</PRE>
<P>generates the following output:</P>
<PRE>
    This gets printed
    culinary delights: carrots</PRE>
<P>The CLEAR directive can be used in a CATCH or FINAL block to clear
any output created in the TRY block.</P>
<PRE>
    [% TRY %]
       This gets printed 
       [% THROW food 'carrots' %]
       This doesn't
    [% CATCH food %]
       [% CLEAR %]
       culinary delights: [% error.info %]
    [% END %]</PRE>
<P>output:</P>
<PRE>
    culinary delights: carrots
</PRE>
<PRE>

Exception types are hierarchical, with each level being separated by
the familiar dot operator.  A 'DBI.connect' exception is a more
specific kind of 'DBI' error.  Similarly, a 'myown.error.barf' is a
more specific kind of 'myown.error' type which itself is also a
'myown' error.  A CATCH handler that specifies a general exception
type (such as 'DBI' or 'myown.error') will also catch more specific
types that have the same prefix as long as a more specific handler
isn't defined.  Note that the order in which CATCH handlers are
defined is irrelevant; a more specific handler will always catch an
exception in preference to a more generic or default one.</PRE>
<PRE>
    [% TRY %]
       ...
    [% CATCH DBI ;
         INCLUDE database/error.html ;
       CATCH DBI.connect ;
         INCLUDE database/connect.html ;
       CATCH ; 
         INCLUDE error.html ;
       END
    %]</PRE>
<P>In this example, a 'DBI.connect' error has it's own handler, a more
general 'DBI' block is used for all other DBI or DBI.* errors and a 
default handler catches everything else.</P>
<P>Exceptions can be raised in a template using the THROW directive.  The
first parameter is the exception type which doesn't need to be quoted
(but can be, it's the same as INCLUDE) followed by the relevant error
message which can be any regular value such as a quoted string,
variable, etc.</P>
<PRE>
    [% THROW food &quot;Missing ingredients: $recipe.error&quot; %]</PRE>
<PRE>
    [% THROW user.login 'no user id: please login' %]</PRE>
<PRE>
    [% THROW $myerror.type &quot;My Error: $myerror.info&quot; %]</PRE>
<P>Exceptions can also be thrown from Perl code which you've bound to
template variables, or defined as a plugin or other extension.  To
raise an exception, call <CODE>die()</CODE> passing a reference to a
Template::Exception object as the argument.  This will then be caught
by any enclosing TRY blocks from where the code was called.</P>
<PRE>
    use Template::Exception;
    ...</PRE>
<PRE>
    my $vars = {
        foo =&gt; sub {
            # ... do something ...
            die Template::Exception-&gt;new('myerr.naughty',
                                         'Bad, bad error');
        },
    };</PRE>
<P>template:</P>
<PRE>
    [% TRY %]
       ...
       [% foo %]
       ...   
    [% CATCH myerr ;
         &quot;Error: $error&quot; ;
       END
    %]</PRE>
<P>output:</P>
<PRE>
    Error: myerr.naughty error - Bad, bad error</PRE>
<P>You can also call <CODE>die()</CODE> with a single string, as is common in much 
existing Perl code.  This will automatically be converted to an 
exception of the 'undef' type (that's the literal string 'undef', 
not the undefined value).  If the string isn't terminated with a 
newline then Perl will append the familiar `` at $file line $line''
message.</P>
<PRE>
    sub foo {
        # ... do something ...
        die &quot;I'm sorry, Dave, I can't do that\n&quot;;
    }</PRE>
<P>If you're writing a plugin, or some extension code that has the
current Template::Context in scope (you can safely skip this section
if this means nothing to you) then you can also raise an exception by
calling the context <CODE>throw()</CODE> method.  You can pass it an
Template::Exception object reference, a pair of ($type, $info) parameters
or just an $info string to create an exception of 'undef' type.</P>
<PRE>
    $context-&gt;throw($e);            # exception object
    $context-&gt;throw('Denied');      # 'undef' type
    $context-&gt;throw('user.passwd', 'Bad Password');</PRE>
<P></P>
<DT><STRONG><A NAME="item_NEXT">NEXT</A></STRONG><BR>
<DD>
The NEXT directive can be used to start the next iteration of a FOREACH 
or WHILE loop.
<PRE>
    [% FOREACH user = userlist %]
       [% NEXT IF user.isguest %]
       Name: [% user.name %]    Email: [% user.email %]
    [% END %]</PRE>
<P></P>
<DT><STRONG><A NAME="item_LAST">LAST</A></STRONG><BR>
<DD>
The LAST directive can be used to prematurely exit a FOREACH or WHILE
loop.
<PRE>
    [% FOREACH user = userlist %]
       Name: [% user.name %]    Email: [% user.email %]
       [% LAST IF some.condition %]
    [% END %]</PRE>
<P>BREAK can also be used as an alias for LAST.</P>
<P></P>
<DT><STRONG><A NAME="item_RETURN">RETURN</A></STRONG><BR>
<DD>
The RETURN directive can be used to stop processing the current
template and return to the template from which it was called, resuming
processing at the point immediately after the INCLUDE, PROCESS or
WRAPPER directive.  If there is no enclosing template then the
Template <CODE>process()</CODE> method will return to the calling code with a 
true value.
<PRE>
    Before
    [% INCLUDE half_wit %]
    After
</PRE>
<PRE>

    [% BLOCK half_wit %]
    This is just half...
    [% RETURN %]
    ...a complete block
    [% END %]</PRE>
<P>output:</P>
<PRE>
    Before
    This is just half...
    After</PRE>
<P></P>
<DT><STRONG><A NAME="item_STOP">STOP</A></STRONG><BR>
<DD>
The STOP directive can be used to indicate that the processor should
stop gracefully without processing any more of the template document.
This is a planned stop and the Template <CODE>process()</CODE> method will return a
<STRONG>true</STRONG> value to the caller.  This indicates that the template was
processed successfully according to the directives within it.
<PRE>
    [% IF something.terrible.happened %]
       [% INCLUDE fatal/error.html %]
       [% STOP %]
    [% END %]</PRE>
<PRE>
    [% TRY %]
       [% USE DBI(mydsn) %]
       ...
    [% CATCH DBI.connect %]
       &lt;p&gt;Cannot connect to the database: [% error.info %]&lt;/p&gt;
       &lt;br&gt;
       We apologise for the inconvenience.  The cleaning lady 
       has removed the server power to plug in her vacuum cleaner.
       Please try again later.
       &lt;/p&gt;
       [% INCLUDE footer %]
       [% STOP %]
    [% END %]</PRE>
<P></P>
<DT><STRONG><A NAME="item_CLEAR">CLEAR</A></STRONG><BR>
<DD>
The CLEAR directive can be used to clear the output buffer for the current
enclosing block.   It is most commonly used to clear the output generated
from a TRY block up to the point where the error occurred.
<PRE>
    [% TRY %]
       blah blah blah            # this is normally left intact
       [% THROW some 'error' %]  # up to the point of error
       ...
    [% CATCH %]
       [% CLEAR %]               # clear the TRY output
       [% error %]               # print error string
    [% END %]</PRE>
<P></P></DL>
<P>
<H2><A NAME="miscellaneous">Miscellaneous</A></H2>
<DL>
<DT><STRONG><A NAME="item_META">META</A></STRONG><BR>
<DD>
The META directive allows simple metadata items to be defined within a 
template.  These are evaluated when the template is parsed and as such
may only contain simple values (e.g. it's not possible to interpolate 
other variables values into META variables).
<PRE>
    [% META
       title   = 'The Cat in the Hat'
       author  = 'Dr. Seuss'
       version = 1.23 
    %]</PRE>
<P>The 'template' variable contains a reference to the main template 
being processed.  These metadata items may be retrieved as attributes
of the template.</P>
<PRE>
    &lt;h1&gt;[% template.title %]&lt;/h1&gt;
    &lt;h2&gt;[% template.author %]&lt;/h2&gt;</PRE>
<P>The 'name' and 'modtime' metadata items are automatically defined for
each template to contain its name and modification time in seconds
since the epoch.</P>
<PRE>
    [% USE date %]              # use Date plugin to format time
    ...
    [% template.name %] last modified
    at [% date.format(template.modtime) %]</PRE>
<P>The PRE_PROCESS and POST_PROCESS options allow common headers and 
footers to be added to all templates.  The 'template' reference is
correctly defined when these templates are processed, allowing headers
and footers to reference metadata items from the main template.</P>
<PRE>
    $template = Template-&gt;new({
        PRE_PROCESS  =&gt; 'header',
        POST_PROCESS =&gt; 'footer',
    });</PRE>
<PRE>
    $template-&gt;process('cat_in_hat');</PRE>
<P>header:
    &lt;html&gt;
    &lt;head&gt;
    &lt;title&gt;[% template.title %]&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;</P>
<P>cat_in_hat:
    [% META
       title   = 'The Cat in the Hat'
       author  = 'Dr. Seuss'
       version = 1.23 
       year    = 2000
    %]</P>
<PRE>
    The cat in the hat sat on the mat.</PRE>
<P>footer:
    &lt;hr&gt;
    &amp;copy; [% template.year %] [% template.author %]
    &lt;/body&gt;
    &lt;/html&gt;</P>
<P>The output generated from the above example is:
</P>
<PRE>

    &lt;html&gt;
    &lt;head&gt;
    &lt;title&gt;The Cat in the Hat&lt;/title&gt;
    &lt;/head&gt;
    &lt;body&gt;</PRE>
<PRE>
    The cat in the hat sat on the mat.</PRE>
<PRE>
    &lt;hr&gt;
    &amp;copy; 2000 Dr. Seuss
    &lt;/body&gt;
    &lt;/html&gt;</PRE>
<P></P>
<DT><STRONG><A NAME="item_TAGS">TAGS</A></STRONG><BR>
<DD>
The TAGS directive can be used to set the START_TAG and END_TAG values
on a per-template file basis.
<PRE>
    [% TAGS &lt;+ +&gt; %]</PRE>
<PRE>
    &lt;+ INCLUDE header +&gt;</PRE>
<P>The TAGS directive may also be used to set a named TAG_STYLE</P>
<PRE>
    [% TAGS html %]
    &lt;!-- INCLUDE header --&gt;</PRE>
<P>See the TAGS and TAG_STYLE configuration options for further details.</P>
<P></P></DL>
<P>
<HR>
<H1><A NAME="configuration options">CONFIGURATION OPTIONS</A></H1>
<P>The Template module accepts configuration items destined for any other 
Template::* module that it may create and will forward them appropriately.
The following list summarises the various options under several broad 
categories.</P>
<P>
<H2><A NAME="template style and parsing options">Template Style and Parsing Options</A></H2>
<DL>
<DT><STRONG><A NAME="item_START_TAG%2C_END_TAG">START_TAG, END_TAG</A></STRONG><BR>
<DD>
The START_TAG and END_TAG options are used to specify character
sequences or regular expressions that mark the start and end of a
template directive.  The default values for START_TAG and END_TAG are
'[%' and '%]' respectively, giving us the familiar directive style:
<PRE>
    [% example %]</PRE>
<P>Any Perl regex characters can be used and therefore should be escaped
(or use the Perl <CODE>quotemeta</CODE> function) if they are intended to
represent literal characters.</P>
<PRE>
    my $template = Template-&gt;new({ 
        START_TAG =&gt; quotemeta('&lt;+'),
        END_TAG   =&gt; quotemeta('+&gt;'),
    });</PRE>
<P>example:</P>
<PRE>
    &lt;+ INCLUDE foobar +&gt;</PRE>
<P>The TAGS directive can also be used to set the START_TAG and END_TAG values
on a per-template file basis.</P>
<PRE>
    [% TAGS &lt;+ +&gt; %]</PRE>
<P></P>
<DT><STRONG><A NAME="item_TAG_STYLE">TAG_STYLE</A></STRONG><BR>
<DD>
The TAG_STYLE option can be used to set both START_TAG and END_TAG
according to pre-defined tag styles.
<PRE>
    my $template = Template-&gt;new({ 
        TAG_STYLE =&gt; 'php',
    });</PRE>
<P>Available styles are:</P>
<PRE>
    template    [% ... %]               (default)
    template1   [% ... %] or %% ... %%  (Template version 1)
    metatext    %% ... %%               (Text::MetaText)
    php         &lt;? ... ?&gt;               (PHP)
    asp         &lt;% ... %&gt;               (ASP)
    mason       &lt;% ...  &gt;               (HTML::Mason)
    html        &lt;!-- ... --&gt;            (HTML comments)</PRE>
<P>Any values specified for START_TAG and/or END_TAG will over-ride
those defined by a TAG_STYLE.</P>
<P>The TAGS directive may also be used to set a TAG_STYLE</P>
<PRE>
    [% TAGS html %]
    &lt;!-- INCLUDE header --&gt;</PRE>
<P></P>
<DT><STRONG><A NAME="item_PRE_CHOMP%2C_POST_CHOMP">PRE_CHOMP, POST_CHOMP</A></STRONG><BR>
<DD>
Anything outside a directive tag is considered plain text and is
generally passed through unaltered (but see the INTERPOLATE option).
This includes all whitespace and newlines characters surrounding
directive tags.  Directives that don't generate any output will leave
gaps in the output document.
<P>Example:</P>
<PRE>
    Foo
    [% a = 10 %]
    Bar</PRE>
<P>Output:</P>
<PRE>
    Foo</PRE>
<PRE>
    Bar</PRE>
<P>The PRE_CHOMP and POST_CHOMP options can help to clean up some of this
extraneous whitespace.  Both are disabled by default.</P>
<PRE>
    my $template = Template-&gt;new({
        PRE_CHOMP  =&gt; 1,
        POST_CHOMP =&gt; 1,
    });</PRE>
<P>With PRE_CHOMP set true, the newline and whitespace preceeding a directive
at the start of a line will be deleted.  This has the effect of 
concatenating a line that starts with a directive onto the end of the 
previous line.</P>
<PRE>
        Foo &lt;----------.
                       |
    ,---(PRE_CHOMP)----'
    |
    `-- [% a = 10 %] --.
                       |
    ,---(POST_CHOMP)---'
    |
    `-&gt; Bar</PRE>
<P>With POST_CHOMP set true, any whitespace after a directive up to and
including the newline will be deleted.  This has the effect of joining
a line that ends with a directive onto the start of the next line.</P>
<P>PRE_CHOMP and POST_CHOMP can be activated for individual directives by
placing a '-' immediately at the start and/or end of the directive.</P>
<PRE>
    [% FOREACH user = userlist %]
       [%- user -%]
    [% END %]</PRE>
<P>The '-' characters activate both PRE_CHOMP and POST_CHOMP for the one
directive '[%- name -%]'.  Thus, the template will be processed as if
written:</P>
<PRE>
    [% FOREACH user = userlist %][% user %][% END %]</PRE>
<P>Similarly, '+' characters can be used to disable PRE_CHOMP or
POST_CHOMP (i.e.  leave the whitespace/newline intact) options on a
per-directive basis.</P>
<PRE>
    [% FOREACH user = userlist %]
    User: [% user +%]
    [% END %]</PRE>
<P>With POST_CHOMP enabled, the above example would be parsed as if written:</P>
<PRE>
    [% FOREACH user = userlist %]User: [% user %]
    [% END %]</PRE>
<P></P>
<DT><STRONG><A NAME="item_TRIM">TRIM</A></STRONG><BR>
<DD>
The TRIM option can be set to have any leading and trailing whitespace 
automatically removed from the output of all template files and BLOCKs.
<P>By example, the following BLOCK definition</P>
<PRE>
    [% BLOCK foo %]
    Line 1 of foo
    [% END %]</PRE>
<P>will be processed is as ``\nLine 1 of foo\n''.  When INCLUDEd, the surrounding
newlines will also be introduced.</P>
<PRE>
    before 
    [% INCLUDE foo %]
    after</PRE>
<P>output:
    before</P>
<PRE>
    Line 1 of foo</PRE>
<PRE>
    after</PRE>
<P>With the TRIM option set to any true value, the leading and trailing
newlines (which count as whitespace) will be removed from the output 
of the BLOCK.</P>
<PRE>
    before
    Line 1 of foo
    after</PRE>
<P>The TRIM option is disabled (0) by default.</P>
<P></P>
<DT><STRONG><A NAME="item_INTERPOLATE">INTERPOLATE</A></STRONG><BR>
<DD>
The INTERPOLATE flag, when set to any true value will cause variable 
references in plain text (i.e. not surrounded by START_TAG and END_TAG)
to be recognised and interpolated accordingly.
<PRE>
    my $template = Template-&gt;new({ 
        INTERPOLATE =&gt; 1,
    });</PRE>
<P>Variables should be prefixed by a '$' to identify them.  Curly braces
can be used in the familiar Perl/shell style to explicitly scope the
variable name where required.</P>
<PRE>
    # INTERPOLATE =&gt; 0
    &lt;a href=&quot;<A HREF="http://">http://</A>[% server %]/[% help %]&quot;&gt;
    &lt;img src=&quot;[% images %]/help.gif&quot;&gt;&lt;/a&gt;
    [% myorg.name %]
</PRE>
<PRE>

    # INTERPOLATE =&gt; 1
    &lt;a href=&quot;<A HREF="http://">http://</A>$server/$help&quot;&gt;
    &lt;img src=&quot;$images/help.gif&quot;&gt;&lt;/a&gt;
    $myorg.name</PRE>
<PRE>

    # explicit scoping with {  }
    &lt;img src=&quot;$images/${icon.next}.gif&quot;&gt;</PRE>
<P>Note that a limitation in Perl's regex engine restricts the maximum length
of an interpolated template to around 32 kilobytes or possibly less.  Files
that exceed this limit in size will typically cause Perl to dump core with
a segmentation fault.  If you routinely process templates of this size 
then you should disable INTERPOLATE or split the templates in several 
smaller files or blocks which can then be joined backed together via 
PROCESS or INCLUDE.</P>
<P></P>
<DT><STRONG><A NAME="item_ANYCASE">ANYCASE</A></STRONG><BR>
<DD>
By default, directive keywords should be expressed in UPPER CASE.  The 
ANYCASE option can be set to allow directive keywords to be specified
in any case.
<PRE>
    # ANYCASE =&gt; 0 (default)
    [% INCLUDE foobar %]        # OK
    [% include foobar %]        # ERROR
    [% include = 10   %]        # OK, 'include' is a variable</PRE>
<PRE>
    # ANYCASE =&gt; 1
    [% INCLUDE foobar %]        # OK
    [% include foobar %]        # OK
    [% include = 10   %]        # ERROR, 'include' is reserved word</PRE>
<P>One side-effect of enabling ANYCASE is that you cannot use a variable
of the same name as a reserved word, regardless of case.  The reserved
words are currently:</P>
<PRE>
    GET CALL SET DEFAULT INSERT INCLUDE PROCESS WRAPPER 
    IF UNLESS ELSE ELSIF FOR FOREACH WHILE SWITCH CASE
    USE PLUGIN FILTER MACRO PERL RAWPERL BLOCK META
    TRY THROW CATCH FINAL NEXT LAST BREAK RETURN STOP 
    CLEAR TO STEP AND OR NOT MOD DIV END</PRE>
<P>The only lower case reserved words that cannot be used for variables,
regardless of the ANYCASE option, are the operators:</P>
<PRE>
    and or not mod div</PRE>
<P></P></DL>
<P>
<H2><A NAME="template files and blocks">Template Files and Blocks</A></H2>
<DL>
<DT><STRONG><A NAME="item_INCLUDE_PATH">INCLUDE_PATH</A></STRONG><BR>
<DD>
The INCLUDE_PATH is used to specify one or more directories in which
template files are located.  When a template is requested that isn't
defined locally as a BLOCK, each of the INCLUDE_PATH directories is
searched in turn to locate the template file.  Multiple directories
can be specified as a reference to a list or as a single string where
each directory is delimited by ':'. The DELIMITER option can be set
to redefine the delimiter value.
<PRE>
    my $template = Template-&gt;new({
        INCLUDE_PATH =&gt; '/usr/local/templates',
    });
</PRE>
<PRE>

    my $template = Template-&gt;new({
        INCLUDE_PATH =&gt; '/usr/local/templates:/tmp/my/templates',
    });</PRE>
<PRE>

    my $template = Template-&gt;new({
        INCLUDE_PATH =&gt; [ '/usr/local/templates', 
                          '/tmp/my/templates' ],
    });</PRE>
<P></P>
<DT><STRONG><A NAME="item_DELIMITER">DELIMITER</A></STRONG><BR>
<DD>
Used to provide an alternative delimiter character sequence for 
separating paths specified in the INCLUDE_PATH.  May be useful for 
operating systems that permit the use of ':' in file names.
<PRE>
    # tolerate Silly Billy's file system conventions
    my $template = Template-&gt;new({
        DELIMITER    =&gt; ' ',
        INCLUDE_PATH =&gt; 'C:/HERE/NOW D:/THERE/THEN',
    });</PRE>
<PRE>
    # better solution: install Linux!  :-)</PRE>
<P></P>
<DT><STRONG><A NAME="item_ABSOLUTE">ABSOLUTE</A></STRONG><BR>
<DD>
The ABSOLUTE flag is used to indicate if templates specified with
absolute filenames (e.g. '/foo/bar') should be processed.  It is
disabled by default and any attempt to load a template by such a
name will cause a 'file' exception to be raised.
<PRE>
    my $template = Template-&gt;new({
        ABSOLUTE =&gt; 1,
    });</PRE>
<PRE>
    # this is why it's disabled by default
    [% INSERT /etc/passwd %]</PRE>
<P></P>
<DT><STRONG><A NAME="item_RELATIVE">RELATIVE</A></STRONG><BR>
<DD>
The RELATIVE flag is used to indicate if templates specified with
filenames relative to the current directory (e.g. './foo/bar' or
'../../some/where/else') should be loaded.  It is also disabled by
default, and will raise a 'file' error if such template names are
encountered.
<PRE>
    my $template = Template-&gt;new({
        RELATIVE =&gt; 1,
    });</PRE>
<PRE>
    [% INCLUDE ../logs/error.log %]</PRE>
<P></P>
<DT><STRONG>DEFAULT</STRONG><BR>
<DD>
The DEFAULT option can be used to specify a default template which should 
be used whenever a specified template can't be found in the INCLUDE_PATH.
<PRE>
    my $template = Template-&gt;new({
        DEFAULT =&gt; 'notfound.html',
    });</PRE>
<P>If a non-existant template is requested through the Template <CODE>process()</CODE>
method, or by an INCLUDE, PROCESS or WRAPPER directive, then the
DEFAULT template will instead be processed, if defined.  Note that the
DEFAULT template is not used when templates are specified with
absolute or relative filenames, or as a reference to a input file
handle or text string.</P>
<P></P>
<DT><STRONG><A NAME="item_BLOCKS">BLOCKS</A></STRONG><BR>
<DD>
The BLOCKS option can be used to pre-define a default set of template 
blocks.  These should be specified as a reference to a hash array 
mapping template names to template text, subroutines or Template::Document
objects.
<PRE>
    my $template = Template-&gt;new({
        BLOCKS =&gt; {
            header  =&gt; 'The Header.  [% title %]',
            footer  =&gt; sub { return $some_output_text },
            another =&gt; Template::Document-&gt;new({ ... }),
        },
    });</PRE>
<P></P>
<DT><STRONG><A NAME="item_AUTO_RESET">AUTO_RESET</A></STRONG><BR>
<DD>
The AUTO_RESET option is set by default and causes the local BLOCKS
cache for the Template::Context object to be reset on each call to the
Template <CODE>process()</CODE> method.  This ensures that any BLOCKs defined
within a template will only persist until that template is finished
processing.  This prevents BLOCKs defined in one processing request
from interfering with other independant requests subsequently
processed by the same context object.
<P>The BLOCKS item may be used to specify a default set of block definitions
for the Template::Context object.  Subsequent BLOCK definitions in templates
will over-ride these but they will be reinstated on each reset if AUTO_RESET
is enabled (default), or if the Template::Context <CODE>reset()</CODE> method is called.</P>
<P></P>
<DT><STRONG><A NAME="item_RECURSION">RECURSION</A></STRONG><BR>
<DD>
The template processor will raise a file exception if it detects
direct or indirect recursion into a template.  Setting this option to 
any true value will allow templates to include each other recursively.
<P></P></DL>
<P>
<H2><A NAME="template variables">Template Variables</A></H2>
<DL>
<DT><STRONG><A NAME="item_VARIABLES%2C_PRE_DEFINE">VARIABLES, PRE_DEFINE</A></STRONG><BR>
<DD>
The VARIABLES option (or PRE_DEFINE - they're equivalent) can be used
to specify a hash array of template variables that should be used to
pre-initialise the stash when it is created.  These items are ignored
if the STASH item is defined.
<PRE>
    my $template = Template-&gt;new({
        VARIABLES =&gt; {
            title   =&gt; 'A Demo Page',
            author  =&gt; 'Joe Random Hacker',
            version =&gt; 3.14,
        },
    };</PRE>
<P>or</P>
<PRE>
    my $template = Template-&gt;new({
        PRE_DEFINE =&gt; {
            title   =&gt; 'A Demo Page',
            author  =&gt; 'Joe Random Hacker',
            version =&gt; 3.14,
        },
    };</PRE>
<P></P></DL>
<P>
<H2><A NAME="runtime processing options">Runtime Processing Options</A></H2>
<DL>
<DT><STRONG><A NAME="item_EVAL_PERL">EVAL_PERL</A></STRONG><BR>
<DD>
This flag is used to indicate if PERL and/or RAWPERL blocks should be 
evaluated.  By default, it is disabled and any PERL or RAWPERL blocks 
encountered will be ignored.  Note however that any RAWPERL blocks 
should always contain valid Perl code, regardless of the EVAL_PERL 
flag.  The parser will fail to compile templates that contain invalid
Perl code in RAWPERL blocks and will throw a 'file' exception.
<P></P>
<DT><STRONG><A NAME="item_PRE_PROCESS%2C_POST_PROCESS">PRE_PROCESS, POST_PROCESS</A></STRONG><BR>
<DD>
These values may be set to contain the <CODE>name(s)</CODE> of template files
(relative to INCLUDE_PATH) which should be processed immediately
before and/or after each template.  These do not get added to 
templates processed into a document via directives such as INCLUDE, 
PROCESS, WRAPPER etc.
<PRE>
    my $template = Template-&gt;new({
        PRE_PROCESS  =&gt; 'header',
        POST_PROCESS =&gt; 'footer',
    };</PRE>
<P>Multiple templates may be specified as a reference to a list.  Each is 
processed in the order defined.</P>
<PRE>
    my $template = Template-&gt;new({
        PRE_PROCESS  =&gt; [ 'config', 'header' ],
        POST_PROCESS =&gt; 'footer',
    };</PRE>
<P>Alternately, multiple template may be specified as a single string, 
delimited by ':'.  This delimiter string can be changed via the 
DELIMITER option.</P>
<PRE>
    my $template = Template-&gt;new({
        PRE_PROCESS  =&gt; 'config:header',
        POST_PROCESS =&gt; 'footer',
    };</PRE>
<P>The PRE_PROCESS and POST_PROCESS templates are evaluated in the same
variable context as the main document and may define or update
variables for subseqent use.</P>
<P>config:
    [% # set some site-wide variables
       bgcolor = '#ffffff'
       version = 2.718
    %]</P>
<P>header:
    [% DEFAULT title = 'My Funky Web Site' %]
    &lt;html&gt;
    &lt;head&gt;
    &lt;title&gt;[% title %]&lt;/title&gt;
    &lt;/head&gt;
    &lt;body bgcolor=``[% bgcolor %]''&gt;</P>
<P>footer:
    &lt;hr&gt;
    Version [% version %]
    &lt;/body&gt;
    &lt;/html&gt;</P>
<P>The Template::Document object representing the main template being processed
is available within PRE_PROCESS and POST_PROCESS templates as the 'template'
variable.  Metadata items defined via the META directive may be accessed 
accordingly.</P>
<PRE>
    $template-&gt;process('mydoc.html', $vars);</PRE>
<P>mydoc.html:
    [% META title = 'My Document Title' %]
    blah blah blah
    ...</P>
<P>header:
    &lt;html&gt;
    &lt;head&gt;
    &lt;title&gt;[% template.title %]&lt;/title&gt;&lt;/head&gt;
    &lt;body bgcolor=``[% bgcolor %]''&gt;</P>
<P></P>
<DT><STRONG>PROCESS</STRONG><BR>
<DD>
The PROCESS option may be set to contain the <CODE>name(s)</CODE> of template files
(relative to INCLUDE_PATH) which should be processed instead of the 
main template passed to the Template <CODE>process()</CODE> method.  This can 
be used to apply consistent wrappers around all templates, similar to 
the use of PRE_PROCESS and POST_PROCESS templates.
<PRE>
    my $template = Template-&gt;new({
        PROCESS  =&gt; 'content',
    };</PRE>
<PRE>
    # processes 'content' instead of 'foo.html'
    $template-&gt;process('foo.html');</PRE>
<P>A reference to the original template is available in the 'template'
variable.  Metadata items can be inspected and the template can be
processed by specifying it as a variable reference (i.e. prefixed by
'$') to an INCLUDE, PROCESS or WRAPPER directive.</P>
<P>content:</P>
<PRE>
    &lt;html&gt;
    &lt;head&gt;
    &lt;title&gt;[% template.title %]&lt;/title&gt;
    &lt;/head&gt;
</PRE>
<PRE>

    &lt;body&gt;
    [% PROCESS $template %]
    &lt;hr&gt;
    &amp;copy; Copyright [% template.copyright %]
    &lt;/body&gt;
    &lt;/html&gt;</PRE>
<P>foo.html:</P>
<PRE>
    [% META 
       title     = 'The Foo Page'
       author    = 'Fred Foo'
       copyright = '2000 Fred Foo'
    %]
    &lt;h1&gt;[% template.title %]&lt;/h1&gt;
    Welcome to the Foo Page, blah blah blah</PRE>
<P>output:</P>
<PRE>
    &lt;html&gt;
    &lt;head&gt;
    &lt;title&gt;The Foo Page&lt;/title&gt;
    &lt;/head&gt;</PRE>
<PRE>
    &lt;body&gt;
    &lt;h1&gt;The Foo Page&lt;/h1&gt;
    Welcome to the Foo Page, blah blah blah
    &lt;hr&gt;
    &amp;copy; Copyright 2000 Fred Foo
    &lt;/body&gt;
    &lt;/html&gt;</PRE>
<P></P>
<DT><STRONG><A NAME="item_ERROR">ERROR</A></STRONG><BR>
<DD>
The ERROR (or ERRORS if you prefer) configuration item can be used to
name a single template or specify a hash array mapping exception types
to templates which should be used for error handling.  If an uncaught
exception is raised from within a template then the appropriate error
template will instead be processed.
<P>If specified as a single value then that template will be processed 
for all uncaught exceptions.</P>
<PRE>
    my $template = Template-&gt;new({
        ERROR =&gt; 'error.html'
    });</PRE>
<P>If the ERROR item is a hash reference the keys are assumed to be
exception types and the relevant template for a given exception will
be selected.  A 'default' template may be provided for the general
case.  Note that 'ERROR' can be pluralised to 'ERRORS' if you find
it more appropriate in this case.</P>
<PRE>
    my $template = Template-&gt;new({
        ERRORS =&gt; {
            user     =&gt; 'user/index.html',
            dbi      =&gt; 'error/database',
            default  =&gt; 'error/default',
        },
    });</PRE>
<P>In this example, any 'user' exceptions thrown will cause the
'user/index.html' template to be processed, 'dbi' errors are handled
by 'error/database' and all others by the 'error/default' template.
Any PRE_PROCESS and/or POST_PROCESS templates will also be applied
to these error templates.</P>
<P>Note that exception types are hierarchical and a 'foo' handler will
catch all 'foo.*' errors (e.g. foo.bar, foo.bar.baz) if a more
specific handler isn't defined.  Be sure to quote any exception types
that contain periods to prevent Perl concatenating them into a single
string (i.e. <CODE>user.passwd</CODE> is parsed as 'user'.'passwd').</P>
<PRE>
    my $template = Template-&gt;new({
        ERROR =&gt; {
            'user.login'  =&gt; 'user/login.html',
            'user.passwd' =&gt; 'user/badpasswd.html',
            'user'        =&gt; 'user/index.html',
            'default'     =&gt; 'error/default',
        },
    });</PRE>
<P>In this example, any template processed by the $template object, or
other templates or code called from within, can raise a 'user.login'
exception and have the service redirect to the 'user/login.html'
template.  Similarly, a 'user.passwd' exception has a specific 
handling template, 'user/badpasswd.html', while all other 'user' or
'user.*' exceptions cause a redirection to the 'user/index.html' page.
All other exception types are handled by 'error/default'.</P>
<P>Exceptions can be raised in a template using the THROW directive,</P>
<PRE>
    [% THROW user.login 'no user id: please login' %]</PRE>
<P>or by calling the <CODE>throw()</CODE> method on the current Template::Context object,</P>
<PRE>
    $context-&gt;throw('user.passwd', 'Incorrect Password');
    $context-&gt;throw('Incorrect Password');    # type 'undef'</PRE>
<P>or from Perl code by calling <CODE>die()</CODE> with a Template::Exception object,</P>
<PRE>
    die Template::Exception-&gt;new('user.denied', 'Invalid User ID');</PRE>
<P>or by simply calling <CODE>die()</CODE> with an error string.  This is
automagically caught and converted to an  exception of 'undef'
type which can then be handled in the usual way.</P>
<PRE>
    die &quot;I'm sorry Dave, I can't do that&quot;;</PRE>
<P></P>
<DT><STRONG><A NAME="item_OUTPUT">OUTPUT</A></STRONG><BR>
<DD>
Default output location or handler.  This may be specified as one of:
a file name (relative to OUTPUT_PATH, if defined, or the current
working directory if not specified absolutely); a file handle
(e.g. GLOB or IO::Handle) opened for writing; a reference to a text
string to which the output is appended (the string isn't cleared); a
reference to a subroutine which is called, passing the output text as
an argument; or as a reference to any object that supports the <CODE>print()</CODE>
method.  This latter option includes the Apache::Request object which
is passed as the argument to Apache/mod_perl handlers.
<P>example 1 (file name):</P>
<PRE>
    my $template = Template-&gt;new({
        OUTPUT =&gt; &quot;/tmp/foo&quot;,
    });</PRE>
<P>example 2 (text string):</P>
<PRE>
    my $output = '';</PRE>
<PRE>
    my $template = Template-&gt;new({
        OUTPUT =&gt; \$output,
    });</PRE>
<P>example 3 (file handle):</P>
<PRE>
    open (TOUT, &quot;&gt; $file&quot;) || die &quot;$file: $!\n&quot;;</PRE>
<PRE>
    my $template = Template-&gt;new({
        OUTPUT =&gt; \*TOUT,
    });</PRE>
<P>example 4 (subroutine):</P>
<PRE>
    sub output { my $out = shift; print &quot;OUTPUT: $out&quot; }</PRE>
<PRE>
    my $template = Template-&gt;new({
        OUTPUT =&gt; \&amp;output,
    });</PRE>
<P>example 5 (Apache/mod_perl handler):</P>
<PRE>
    sub handler {
        my $r = shift;</PRE>
<PRE>
        my $t = Template-&gt;new({
            OUTPUT =&gt; $r,
        });
        ...
    }</PRE>
<P>The default OUTPUT location be overridden by passing a third parameter
to the Template <CODE>process()</CODE> method.  This can be specified as any of the 
above argument types.</P>
<PRE>
    $t-&gt;process($file, $vars, &quot;/tmp/foo&quot;);
    $t-&gt;process($file, $vars, &quot;bar&quot;);
    $t-&gt;process($file, $vars, \*MYGLOB);
    $t-&gt;process($file, $vars, $r);  # Apache::Request
    ...</PRE>
<P></P>
<DT><STRONG><A NAME="item_OUTPUT_PATH">OUTPUT_PATH</A></STRONG><BR>
<DD>
The OUTPUT_PATH allows a directory to be specified into which output
files should be written.  An output file can be specified by the 
OUTPUT option, or passed by name as the third paramater to the 
Template <CODE>process()</CODE> method.
<PRE>
    my $template = Template-&gt;new({
        INPUT_PATH  =&gt; &quot;/tmp/src&quot;,
        OUTPUT_PATH =&gt; &quot;/tmp/dest&quot;,
    });</PRE>
<PRE>
    my $vars = {
        ...
    };</PRE>
<PRE>
    foreach my $file ('foo.html', 'bar.html') {
        $template-&gt;process($file, $vars, $file)
            || die $template-&gt;error();  
    }</PRE>
<P>This example will read the input files '/tmp/src/foo.html' and 
'/tmp/src/bar.html' and write the processed output to '/tmp/dest/foo.html'
and '/tmp/dest/bar.html', respectively.</P>
<P></P></DL>
<P>
<H2><A NAME="caching and compiling options">Caching and Compiling Options</A></H2>
<DL>
<DT><STRONG><A NAME="item_CACHE_SIZE">CACHE_SIZE</A></STRONG><BR>
<DD>
The Template::Provider module caches compiled templates to avoid the need
to re-parse template files or blocks each time they are used.  The CACHE_SIZE
option is used to limit the number of compiled templates that the module
should cache.
<P>By default, the CACHE_SIZE is undefined and all compiled templates are
cached.  When set to any positive value, the cache will be limited to
storing no more than that number of compiled templates.  When a new
template is loaded and compiled and the cache is full (i.e. the number
of entries == CACHE_SIZE), the least recently used compiled template
is discarded to make room for the new one.</P>
<P>The CACHE_SIZE can be set to 0 to disable caching altogether.</P>
<PRE>
    my $template = Template-&gt;new({
        CACHE_SIZE =&gt; 64,   # only cache 64 compiled templates
    });</PRE>
<PRE>
    my $template = Template-&gt;new({
        CACHE_SIZE =&gt; 0,   # don't cache any compiled templates
    });</PRE>
<P></P>
<DT><STRONG><A NAME="item_COMPILE_EXT">COMPILE_EXT</A></STRONG><BR>
<DD>
From version 2 onwards, the Template Toolkit has the ability to
compile templates to Perl code and save them to disk for subsequent
use (i.e. cache persistance).  The COMPILE_EXT option may be
provided to specify a filename extension for compiled template files.
It is undefined by default and no attempt will be made to read or write 
any compiled template files.
<PRE>
    my $template = Template-&gt;new({
        COMPILE_EXT =&gt; '.ttc',
    });</PRE>
<P>If COMPILE_EXT is defined (and COMPILE_DIR isn't, see below) then compiled
template files with the COMPILE_EXT extension will be written to the same
directory from which the source template files were loaded.</P>
<P>Compiling and subsequent reuse of templates happens automatically
whenever the COMPILE_EXT or COMPILE_DIR options are set.  The Template
Toolkit will automatically reload and reuse compiled files when it 
finds them on disk.  If the corresponding source file has been modified
since the compiled version as written, then it will load and re-compile
the source and write a new compiled version to disk.</P>
<P>This form of cache persistance offers significant benefits in terms of 
time and resources required to reload templates.  Compiled templates can
be reloaded by a simple call to Perl's require(), leaving Perl to handle
all the parsing and compilation.  This is a Good Thing.</P>
<P></P>
<DT><STRONG><A NAME="item_COMPILE_DIR">COMPILE_DIR</A></STRONG><BR>
<DD>
The COMPILE_DIR option is used to specify an alternate directory root
under which compiled template files should be saved.
<PRE>
    my $template = Template-&gt;new({
        COMPILE_DIR =&gt; '/tmp/ttc',
    });</PRE>
<P>The COMPILE_EXT option may also be specified to have a consistent file
extension added to these files.</P>
<PRE>
    my $template1 = Template-&gt;new({
        COMPILE_DIR =&gt; '/tmp/ttc',
        COMPILE_EXT =&gt; '.ttc1',
    });</PRE>
<PRE>
    my $template2 = Template-&gt;new({
        COMPILE_DIR =&gt; '/tmp/ttc',
        COMPILE_EXT =&gt; '.ttc2',
    });</PRE>
<P>When COMPILE_EXT is undefined, the compiled template files have the
same name as the original template files, but reside in a different
directory tree.</P>
<P>Each directory in the INCLUDE_PATH is replicated in full beneath the 
COMPILE_DIR directory.  This example:</P>
<PRE>
    my $template = Template-&gt;new({
        COMPILE_DIR  =&gt; '/tmp/ttc',
        INCLUDE_PATH =&gt; '/home/abw/templates:/usr/share/templates',
    });</PRE>
<P>would create the following directory structure:</P>
<PRE>
    /tmp/ttc/home/abw/templates/
    /tmp/ttc/usr/share/templates/</PRE>
<P>Files loaded from different INCLUDE_PATH directories will have their
compiled forms save in the relevant COMPILE_DIR directory.</P>
<P></P></DL>
<P>
<H2><A NAME="plugins and filters">Plugins and Filters</A></H2>
<DL>
<DT><STRONG><A NAME="item_PLUGINS">PLUGINS</A></STRONG><BR>
<DD>
The PLUGINS options can be used to provide a reference to a hash array
that maps plugin names to Perl module names.  A number of standard
plugins are defined (e.g. 'table', 'cgi', 'dbi', etc.) which map to
their corresponding Template::Plugin::* counterparts.  These can be
redefined by values in the PLUGINS hash.
<PRE>
    my $template = Template-&gt;new({
        PLUGINS =&gt; [
            cgi =&gt; 'MyOrg::Template::Plugin::CGI',
            foo =&gt; 'MyOrg::Template::Plugin::Foo',
            bar =&gt; 'MyOrg::Template::Plugin::Bar',
        ],
    });</PRE>
<P>The USE directive is used to create plugin objects and does so by
calling the <CODE>plugin()</CODE> method on the current Template::Context object.
If the plugin name is defined in the PLUGINS hash then the
corresponding Perl module is loaded via require().  The context then
calls the <CODE>load()</CODE> class method which should return the class name 
(default and general case) or a prototype object against which the 
<CODE>new()</CODE> method can be called to instantiate individual plugin objects.</P>
<P>If the plugin name is not defined in the PLUGINS hash then the PLUGIN_BASE
and/or LOAD_PERL options come into effect.</P>
<P></P>
<DT><STRONG><A NAME="item_PLUGIN_BASE">PLUGIN_BASE</A></STRONG><BR>
<DD>
If a plugin is not defined in the PLUGINS hash then the PLUGIN_BASE is used
to attempt to construct a correct Perl module name which can be successfully 
loaded.
<P>The PLUGIN_BASE can be specified as a single value or as a reference
to an array of multiple values.  The default PLUGIN_BASE value,
'Template::Plugin', is always added the the end of the PLUGIN_BASE
list (a single value is first converted to a list).  Each value should
contain a Perl package name to which the requested plugin name is
appended.</P>
<P>example 1:</P>
<PRE>
    my $template = Template-&gt;new({
        PLUGIN_BASE =&gt; 'MyOrg::Template::Plugin',
    });</PRE>
<PRE>
    [% USE Foo %]    # =&gt; MyOrg::Template::Plugin::Foo
                       or        Template::Plugin::Foo</PRE>
<P>example 2:</P>
<PRE>
    my $template = Template-&gt;new({
        PLUGIN_BASE =&gt; [   'MyOrg::Template::Plugin',
                         'YourOrg::Template::Plugin'  ],
    });</PRE>
<PRE>
    [% USE Foo %]    # =&gt;   MyOrg::Template::Plugin::Foo
                       or YourOrg::Template::Plugin::Foo 
                       or          Template::Plugin::Foo</PRE>
<P></P>
<DT><STRONG><A NAME="item_LOAD_PERL">LOAD_PERL</A></STRONG><BR>
<DD>
If a plugin cannot be loaded using the PLUGINS or PLUGIN_BASE
approaches then the provider can make a final attempt to load the
module without prepending any prefix to the module path.  This allows
regular Perl modules (i.e. those that don't reside in the
Template::Plugin or some other such namespace) to be loaded and used
as plugins.
<P>By default, the LOAD_PERL option is set to 0 and no attempt will be made
to load any Perl modules that aren't named explicitly in the PLUGINS
hash or reside in a package as named by one of the PLUGIN_BASE
components.</P>
<P>Plugins loaded using the PLUGINS or PLUGIN_BASE receive a reference to
the current context object as the first argument to the <CODE>new()</CODE>
constructor.  Modules loaded using LOAD_PERL are assumed to not
conform to the plugin interface.  They must provide a <CODE>new()</CODE> class
method for instantiating objects but it will not receive a reference
to the context as the first argument.  Plugin modules should provide a
<CODE>load()</CODE> class method (or inherit the default one from the
Template::Plugin base class) which is called the first time the plugin
is loaded.  Regular Perl modules need not.  In all other respects,
regular Perl objects and Template Toolkit plugins are identical.</P>
<P>If a particular Perl module does not conform to the common, but not
unilateral, <CODE>new()</CODE> constructor convention then a simple plugin wrapper
can be written to interface to it.</P>
<P></P>
<DT><STRONG><A NAME="item_FILTERS">FILTERS</A></STRONG><BR>
<DD>
The FILTERS option can be used to specify custom filters which can
then be used with the FILTER directive like any other.  These are
added to the standard filters which are available by default.  Filters
specified via this option will mask any standard filters of the same
name.
<P>The FILTERS option should be specified as a reference to a hash array
in which each key represents the name of a filter.  The corresponding
value should contain a reference to an array containing a subroutine
reference and a flag which indicates if the filter is static (0) or
dynamic (1).  A filter may also be specified as a solitary subroutine
reference and is assumed to be static.</P>
<PRE>
    $template = Template-&gt;new({
        FILTERS =&gt; {
            'sfilt1' =&gt;   \&amp;static_filter,      # static
            'sfilt2' =&gt; [ \&amp;static_filter, 0 ], # same as above
            'dfilt1' =&gt; [ \&amp;dyanamic_filter_factory, 1 ],
        },
    });</PRE>
<P>Additional filters can be specified at any time by calling the 
<CODE>define_filter()</CODE> method on the current Template::Context object.
The method accepts a filter name, a reference to a filter 
subroutine and an optional flag to indicate if the filter is 
dynamic.</P>
<PRE>
    my $context = $template-&gt;context();
    $context-&gt;define_filter('new_html', \&amp;new_html);
    $context-&gt;define_filter('new_repeat', \&amp;new_repeat, 1);</PRE>
<P>Static filters are those where a single subroutine reference is used
for all invocations of a particular filter.  Filters that don't accept
any configuration parameters (e.g. 'html') can be implemented
statically.  The subroutine reference is simply returned when that
particular filter is requested.  The subroutine is called to filter
the output of a template block which is passed as the only argument.
The subroutine should return the modified text.</P>
<PRE>
    sub static_filter {
        my $text = shift;
        # do something to modify $text...
        return $text;
    }</PRE>
<P>The following template fragment:</P>
<PRE>
    [% FILTER sfilt1 %]
    Blah blah blah.
    [% END %]</PRE>
<P>is approximately equivalent to:</P>
<PRE>
    &amp;static_filter(&quot;\nBlah blah blah.\n&quot;);</PRE>
<P>Filters that can accept parameters (e.g. 'truncate') should be
implemented dynamically.  In this case, the subroutine is taken to be
a filter 'factory' that is called to create a unique filter subroutine
each time one is requested.  A reference to the current
Template::Context object is passed as the first parameter, followed by
any additional parameters specified.  The subroutine should return
another subroutine reference (usually a closure) which implements the
filter.</P>
<PRE>
    sub dynamic_filter_factory {
        my ($context, @args) = @_;</PRE>
<PRE>
        return sub {
            my $text = shift;
            # do something to modify $text...
            return $text;           
        }
    }</PRE>
<P>The following template fragment:</P>
<PRE>
    [% FILTER dfilt1(123, 456) %] 
    Blah blah blah
    [% END %]</PRE>
<P>is approximately equivalent to:</P>
<PRE>
    my $filter = &amp;dynamic_filter_factory($context, 123, 456);
    &amp;$filter(&quot;\nBlah blah blah.\n&quot;);</PRE>
<P>See the FILTER directive for further examples.</P>
<P></P></DL>
<P>
<H2><A NAME="compatibility, customisation and extension">Compatibility, Customisation and Extension</A></H2>
<DL>
<DT><STRONG><A NAME="item_V1DOLLAR">V1DOLLAR</A></STRONG><BR>
<DD>
In version 1 of the Template Toolkit, an optional leading '$' could be placed
on any template variable and would be silently ignored.
<PRE>
    # VERSION 1
    [% $foo %]       ===  [% foo %]
    [% $hash.$key %] ===  [% hash.key %]</PRE>
<P>To interpolate a variable value the '${' ... '}' construct was used.
Typically, one would do this to index into a hash array when the key
value was stored in a variable.</P>
<P>example:</P>
<PRE>
    my $vars = {
        users =&gt; {
            aba =&gt; { name =&gt; 'Alan Aardvark', ... },
            abw =&gt; { name =&gt; 'Andy Wardley', ... },
            ...
        },
        uid =&gt; 'aba',
        ...
    };</PRE>
<PRE>
    $template-&gt;process('user/home.html', $vars)
        || die $template-&gt;error(), &quot;\n&quot;;</PRE>
<P>'user/home.html':</P>
<PRE>
    [% user = users.${uid} %]     # users.aba
    Name: [% user.name %]         # Alan Aardvark</PRE>
<P>This was inconsistent with double quoted strings and also the
INTERPOLATE mode, where a leading '$' in text was enough to indicate a
variable for interpolation, and the additional curly braces were used
to delimit variable names where necessary.  Note that this use is
consistent with UNIX and Perl conventions, among others.</P>
<PRE>
    # double quoted string interpolation
    [% name = &quot;$title ${user.name}&quot; %]</PRE>
<PRE>
    # INTERPOLATE = 1
    &lt;img src=&quot;$images/help.gif&quot;&gt;&lt;/a&gt;
    &lt;img src=&quot;$images/${icon.next}.gif&quot;&gt;</PRE>
<P>For version 2, these inconsistencies have been removed and the syntax
clarified.  A leading '$' on a variable is now used exclusively to
indicate that the variable name should be interpolated
(e.g. subsituted for its value) before being used.  The earlier example
from version 1:</P>
<PRE>
    # VERSION 1
    [% user = users.${uid} %]
    Name: [% user.name %]</PRE>
<P>can now be simplified in version 2 as:</P>
<PRE>
    # VERSION 2
    [% user = users.$uid %]
    Name: [% user.name %]</PRE>
<P>The leading dollar is no longer ignored and has the same effect of
interpolation as '${' ... '}' in version 1.  The curly braces may
still be used to explicitly scope the interpolated variable name
where necessary.</P>
<P>e.g.</P>
<PRE>
    [% user = users.${me.id} %]
    Name: [% user.name %]</PRE>
<P>The rule applies for all variables, both within directives and in
plain text if processed with the INTERPOLATE option.  This means that
you should no longer (if you ever did) add a leading '$' to a variable
inside a directive, unless you explicitly want it to be interpolated.</P>
<P>One obvious side-effect is that any version 1 templates with variables
using a leading '$' will no longer be processed as expected.  Given
the following variable definitions,</P>
<PRE>
    [% foo = 'bar'
       bar = 'baz'
    %]</PRE>
<P>version 1 would interpret the following as:</P>
<PRE>
    # VERSION 1
    [% $foo %] =&gt; [% GET foo %] =&gt; bar</PRE>
<P>whereas version 2 interprets it as:</P>
<PRE>
    # VERSION 2
    [% $foo %] =&gt; [% GET $foo %] =&gt; [% GET bar %] =&gt; baz</PRE>
<P>In version 1, the '$' is ignored and the value for the variable 'foo' is 
retrieved and printed.  In version 2, the variable '$foo' is first interpolated
to give the variable name 'bar' whose value is then retrieved and printed.</P>
<P>The use of the optional '$' has never been strongly recommended, but
to assist in backwards compatibility with any version 1 templates that
may rely on this ``feature'', the V1DOLLAR option can be set to 1
(default: 0) to revert the behaviour and have leading '$' characters
ignored.</P>
<PRE>
    my $template = Template-&gt;new({
        V1DOLLAR =&gt; 1,
    });</PRE>
<P></P>
<DT><STRONG><A NAME="item_LOAD_TEMPLATES">LOAD_TEMPLATES</A></STRONG><BR>
<DD>
The LOAD_TEMPLATE option can be used to provide a reference to a list
of Template::Provider objects or sub-classes thereof which will take
responsibility for loading and compiling templates.
<PRE>
    my $template = Template-&gt;new({
        LOAD_TEMPLATES =&gt; [
            MyOrg::Template::Provider-&gt;new({ ... }),
            Template::Provider-&gt;new({ ... }),
        ],
    });</PRE>
<P>When a PROCESS, INCLUDE or WRAPPER directive is encountered, the named
template may refer to a locally defined BLOCK or a file relative to
the INCLUDE_PATH (or an absolute or relative path if the appropriate
ABSOLUTE or RELATIVE options are set).  If a BLOCK definition can't be
found (see the Template::Context <A HREF="#item_template"><CODE>template()</CODE></A> method for a discussion of
BLOCK locality) then each of the LOAD_TEMPLATES provider objects is
queried in turn via the <CODE>fetch()</CODE> method to see if it can supply the
required template.  Each provider can return a compiled template, an
error, or decline to service the request in which case the
responsiblity is passed to the next provider.  If none of the
providers can service the request then a 'not found' error is
returned.  The same basic provider mechanism is also used for the 
INSERT directive but it bypasses any BLOCK definitions and doesn't
attempt is to parse or process the contents of the template file.</P>
<P>This is an implementation of the 'Chain of Responsiblity'
design pattern as described in 
``Design Patterns'', Erich Gamma, Richard Helm, Ralph Johnson, John 
Vlissides), Addision-Wesley, ISBN 0-201-63361-2, page 223.</P>
<P>If LOAD_TEMPLATES is undefined, a single default provider will be
instantiated using the current configuration parameters.  For example,
the Template::Provider INCLUDE_PATH option can be specified in the Template configuration and will be correctly passed to the provider's
constructor method.</P>
<PRE>
    my $template = Template-&gt;new({
        INCLUDE_PATH =&gt; '/here:/there',
    });</PRE>
<P></P>
<DT><STRONG><A NAME="item_LOAD_PLUGINS">LOAD_PLUGINS</A></STRONG><BR>
<DD>
The LOAD_PLUGINS options can be used to specify a list of provider
objects (i.e. they implement the <CODE>fetch()</CODE> method) which are responsible
for loading and instantiating template plugin objects.  The
Template::Content <CODE>plugin()</CODE> method queries each provider in turn in a
``Chain of Responsibility'' as per the <A HREF="#item_template"><CODE>template()</CODE></A> and <CODE>filter()</CODE> methods.
<PRE>
    my $template = Template-&gt;new({
        LOAD_PLUGINS =&gt; [
            MyOrg::Template::Plugins-&gt;new({ ... }),
            Template::Plugins-&gt;new({ ... }),
        ],
    });</PRE>
<P>By default, a single Template::Plugins object is created using the 
current configuration hash.  Configuration items destined for the 
Template::Plugins constructor may be added to the Template 
constructor.</P>
<PRE>
    my $template = Template-&gt;new({
        PLUGIN_BASE =&gt; 'MyOrg::Template::Plugins',
        LOAD_PERL   =&gt; 1,
    });</PRE>
<P></P>
<DT><STRONG><A NAME="item_LOAD_FILTERS">LOAD_FILTERS</A></STRONG><BR>
<DD>
The LOAD_FILTERS option can be used to specify a list of provider
objects (i.e. they implement the <CODE>fetch()</CODE> method) which are responsible
for returning and/or creating filter subroutines.  The
Template::Context <CODE>filter()</CODE> method queries each provider in turn in a
``Chain of Responsibility'' as per the <A HREF="#item_template"><CODE>template()</CODE></A> and <CODE>plugin()</CODE> methods.
<PRE>
    my $template = Template-&gt;new({
        LOAD_FILTERS =&gt; [
            MyTemplate::Filters-&gt;new(),
            Template::Filters-&gt;new(),
        ],
    });</PRE>
<P>By default, a single Template::Filters object is created for the
LOAD_FILTERS list.</P>
<P></P>
<DT><STRONG><A NAME="item_TOLERANT">TOLERANT</A></STRONG><BR>
<DD>
The TOLERANT flag is used by the various Template Toolkit provider
modules (Template::Provider, Template::Plugins, Template::Filters) to
control their behaviour when errors are encountered.  By default, any
errors are reported as such, with the request for the particular
resource (template, plugin, filter) being denied and an exception
raised.  When the TOLERANT flag is set to any true values, errors will
be silently ignored and the provider will instead return
STATUS_DECLINED.  This allows a subsequent provider to take
responsibility for providing the resource, rather than failing the
request outright.  If all providers decline to service the request,
either through tolerated failure or a genuine disinclination to
comply, then a '&lt;resource&gt; not found' exception is raised.
<P></P>
<DT><STRONG><A NAME="item_SERVICE">SERVICE</A></STRONG><BR>
<DD>
A reference to a Template::Service object, or sub-class thereof, to which
the Template module should delegate.  If unspecified, a Template::Service
object is automatically created using the current configuration hash.
<PRE>
    my $template = Template-&gt;new({
        SERVICE =&gt; MyOrg::Template::Service-&gt;new({ ... }),
    });</PRE>
<P></P>
<DT><STRONG><A NAME="item_CONTEXT">CONTEXT</A></STRONG><BR>
<DD>
A reference to a Template::Context object which is used to define a 
specific environment in which template are processed.  A Template::Context
object is passed as the only parameter to the Perl subroutines that 
represent ``compiled'' template documents.  Template subroutines make 
callbacks into the context object to access Template Toolkit functionality,
for example, to to INCLUDE or PROCESS another template (include() and 
<CODE>process()</CODE> methods, respectively), to USE a plugin (plugin()) or 
instantiate a filter (filter()) or to access the stash (stash()) which 
manages variable definitions via the <CODE>get()</CODE> and <CODE>set()</CODE> methods.
<PRE>
    my $template = Template-&gt;new({
        CONTEXT =&gt; MyOrg::Template::Context-&gt;new({ ... }),
    });</PRE>
<P></P>
<DT><STRONG><A NAME="item_STASH">STASH</A></STRONG><BR>
<DD>
A reference to a Template::Stash object or sub-class which will take
responsibility for managing template variables.
<PRE>
    my $stash = MyOrg::Template::Stash-&gt;new({ ... });
    my $template = Template-&gt;new({
        STASH =&gt; $stash,
    });</PRE>
<P>If unspecified, a default stash object is created using the VARIABLES
configuration item to initialise the stash variables.  These may also
be specified as the PRE_DEFINE option for backwards compatibility with 
version 1.</P>
<PRE>
    my $template = Template-&gt;new({
        VARIABLES =&gt; {
            id    =&gt; 'abw',
            name  =&gt; 'Andy Wardley',
        },
    };</PRE>
<P></P>
<DT><STRONG><A NAME="item_PARSER">PARSER</A></STRONG><BR>
<DD>
The Template::Parser module implements a parser object for compiling
templates into Perl code which can then be executed.  A default object
of this class is created automatically and then used by the
Template::Provider whenever a template is loaded and requires 
compilation.  The PARSER option can be used to provide a reference to 
an alternate parser object.
<PRE>
    my $template = Template-&gt;new({
        PARSER =&gt; MyOrg::Template::Parser-&gt;new({ ... }),
    });</PRE>
<P></P>
<DT><STRONG><A NAME="item_GRAMMAR">GRAMMAR</A></STRONG><BR>
<DD>
The GRAMMAR configuration item can be used to specify an alternate
grammar for the parser.  This allows a modified or entirely new
template langauge to be constructed and used by the Template Toolkit.
<P>Source templates are compiled to Perl code by the Template::Parser
using the Template::Grammar (by default) to define the language
structure and semantics.  Compiled templates are thus inherently
``compatible'' with each other and there is nothing to prevent any
number of different template languages being compiled and used within
the same Template Toolkit processing environment (other than the usual
time and memory constraints).</P>
<P>The Template::Grammar file is constructed from a YACC like grammar
(using Parse::YAPP) and a skeleton module template.  These files are
provided, along with a small script to rebuild the grammar, in the
'parser' sub-directory of the distribution.  You don't have to know or
worry about these unless you want to hack on the template language or
define your own variant.  There is a README file in the same directory
which provides some small guidance but it is assumed that you know
what you're doing if you venture herein.  If you grok LALR parsers,
then you should find it comfortably familiar.</P>
<P>By default, an instance of the default Template::Grammar will be
created and used automatically if a GRAMMAR item isn't specified.</P>
<PRE>
    use MyOrg::Template::Grammar;</PRE>
<PRE>
    my $template = Template-&gt;new({ 
        GRAMMAR = MyOrg::Template::Grammar-&gt;new();
    });</PRE>
<P></P></DL>
<P>
<HR>
<H1><A NAME="template toolkit filters">TEMPLATE TOOLKIT FILTERS</A></H1>
<P>The following standard filters are distributed with the Template Toolkit.</P>
<DL>
<DT><STRONG><A NAME="item_html">html</A></STRONG><BR>
<DD>
Converts the characters '&lt;', '&gt;' and '&amp;' to '&amp;lt;', '&amp;gt;' and '&amp;amp',
respectively, protecting them from being interpreted as representing
HTML tags or entities.
<PRE>
    [% FILTER html %]
    Binary &quot;&lt;=&gt;&quot; returns -1, 0, or 1 depending on...
    [% END %]</PRE>
<P>output:</P>
<PRE>
    Binary &quot;&amp;lt;=&amp;gt;&quot; returns -1, 0, or 1 depending on...</PRE>
<P></P>
<DT><STRONG><A NAME="item_html_para">html_para</A></STRONG><BR>
<DD>
This filter formats a block of text into HTML paragraphs.  A sequence of 
two or more newlines is used as the delimiter for paragraphs which are 
then wrapped in HTML &lt;p&gt;...&lt;/p&gt; tags.
<PRE>
    [% FILTER html_para %]
    The cat sat on the mat.</PRE>
<PRE>
    Mary had a little lamb.
    [% END %]</PRE>
<P>output:</P>
<PRE>
    &lt;p&gt;
    The cat sat on the mat.
    &lt;/p&gt;</PRE>
<PRE>
    &lt;p&gt;
    Mary had a little lamb.
    &lt;/p&gt;</PRE>
<P></P>
<DT><STRONG><A NAME="item_html_break">html_break</A></STRONG><BR>
<DD>
Similar to the html_para filter described above, but uses the HTML tag
sequence &lt;br&gt;&lt;br&gt; to join paragraphs.
<PRE>
    [% FILTER html_break %]
    The cat sat on the mat.</PRE>
<PRE>
    Mary had a little lamb.
    [% END %]</PRE>
<P>output:</P>
<PRE>
    The cat sat on the mat.
    &lt;br&gt;
    &lt;br&gt;
    Mary had a little lamb.</PRE>
<P></P>
<DT><STRONG><A NAME="item_format"><CODE>format(format)</CODE></A></STRONG><BR>
<DD>
The 'format' filter takes a format string as a parameter (as per
<CODE>printf())</CODE> and formats each line of text accordingly.
<PRE>
    [% FILTER format('&lt;!-- %-40s --&gt;') %]
    This is a block of text filtered 
    through the above format.
    [% END %]</PRE>
<P>output:</P>
<PRE>
    &lt;!-- This is a block of text filtered        --&gt;
    &lt;!-- through the above format.               --&gt;</PRE>
<P></P>
<DT><STRONG><A NAME="item_truncate"><CODE>truncate(length)</CODE></A></STRONG><BR>
<DD>
Truncates the text block to the length specified, or a default length of
32.  Truncated text will be terminated with '...' (i.e. the '...' falls
inside the required length, rather than appending to it).
<PRE>
    [% FILTER truncate(21) %]
    I have much to say on this matter that has previously 
    been said on more than one occassion.
    [% END %]</PRE>
<P>output:</P>
<PRE>
    I have much to say...</PRE>
<P></P>
<DT><STRONG><A NAME="item_repeat"><CODE>repeat(iterations)</CODE></A></STRONG><BR>
<DD>
Repeats the text block for as many iterations as are specified (default: 1).
<PRE>
    [% FILTER repeat(3) %]
    We want more beer and we want more beer,
    [% END %]
    We are the more beer wanters!</PRE>
<P>output:</P>
<PRE>
    We want more beer and we want more beer,
    We want more beer and we want more beer,
    We want more beer and we want more beer,
    We are the more beer wanters!</PRE>
<P></P>
<DT><STRONG><A NAME="item_remove"><CODE>remove(string)</CODE></A></STRONG><BR>
<DD>
Searches the input text for any occurences of the specified string and 
removes them.  A Perl regular expression may be specified as the search 
string.
<PRE>
    [% &quot;The  cat  sat  on  the  mat&quot; FILTER remove('\s+') %]</PRE>
<P>output:</P>
<PRE>
    Thecatsatonthemat</PRE>
<P></P>
<DT><STRONG><A NAME="item_replace">replace(search, replace)</A></STRONG><BR>
<DD>
Similar to the remove filter described above, but taking a second parameter
which is used as a replacement string for instances of the search string.
<PRE>
    [% &quot;The  cat  sat  on  the  mat&quot; | replace('\s+', '_') %]</PRE>
<P>output:</P>
<PRE>
    The_cat_sat_on_the_mat</PRE>
<P></P>
<DT><STRONG><A NAME="item_redirect"><CODE>redirect(file)</CODE></A></STRONG><BR>
<DD>
The 'redirect' filter redirects the output of the block into a separate
file, specified relative to the OUTPUT_PATH configuration item.
<PRE>
    [% FOREACH user = myorg.userlist %]
       [% FILTER redirect(&quot;users/${user.id}.html&quot;) %]
          [% INCLUDE userinfo %]
       [% END %]
    [% END %]</PRE>
<P>or more succinctly, using side-effect notation:</P>
<PRE>
    [% INCLUDE userinfo 
         FILTER redirect(&quot;users/${user.id}.html&quot;)
           FOREACH user = myorg.userlist 
    %]</PRE>
<P>A 'file' exception will be thrown if the OUTPUT_PATH option is undefined.</P>
<P></P>
<DT><STRONG><A NAME="item_eval"><CODE>eval(template_text)</CODE></A></STRONG><BR>
<DD>
The 'eval' filter evaluates the block as template text, processing
any directives embedded within it.  This allows template variables to
contain template fragments, or for some method to be provided for
returning template fragments from an external source such as a
database, which can then be processed in the template as required.
<PRE>
    my $vars  = {
        fragment =&gt; &quot;The cat sat on the [% place %]&quot;,
    };
    $template-&gt;process($file, $vars);</PRE>
<P>The following example:</P>
<PRE>
    [% fragment | eval %]</PRE>
<P>is therefore equivalent to</P>
<PRE>
    The cat sat on the [% place %]</PRE>
<P>The 'evaltt' filter is provided as an alias for 'eval'.</P>
<P></P>
<DT><STRONG><A NAME="item_perl"><CODE>perl(perlcode)</CODE></A></STRONG><BR>
<DD>
The 'perl' filter evaluates the block as Perl code.  The EVAL_PERL
option must be set to a true value or a 'perl' exception will be
thrown.
<PRE>
    [% my_perl_code | perl %]</PRE>
<P>In most cases, the [% PERL %] ... [% END %] block should suffice for 
evaluating Perl code, given that template directives are processed 
before being evaluate as Perl.  Thus, the previous example could have
been written in the more verbose form:</P>
<PRE>
    [% PERL %]
    [% my_perl_code %]
    [% END %]</PRE>
<P>as well as</P>
<PRE>
    [% FILTER perl %]
    [% my_perl_code %]
    [% END %]</PRE>
<P>The 'evalperl' filter is provided as an alias for 'perl' for backwards
compatability.</P>
<P></P></DL>
<P>
<HR>
<H1><A NAME="template toolkit plugins">TEMPLATE TOOLKIT PLUGINS</A></H1>
<P>The following plugin modules are distributed with the Template
Toolkit.  Some of the plugins interface to external modules (detailed
below) which should be downloaded from any CPAN site and installed
before using the plugin.</P>
<DL>
<DT><STRONG><A NAME="item_Autoformat">Autoformat</A></STRONG><BR>
<DD>
The Autoformat plugin is an interface to Damian Conway's Text::Autoformat 
Perl module which provides advanced text wrapping and formatting.  See
<A >the Template::Plugin::Autoformat manpage</A> and <A >the Text::Autoformat manpage</A> for further 
details.
<PRE>
    [% USE autoformat(left=10, right=20) %]
    [% autoformat(mytext) %]        # call autoformat sub
    [% mytext FILTER autoformat %]  # or use autoformat filter</PRE>
<P>The Text::Autoformat module is available from CPAN:</P>
<PRE>
    <A HREF="http://www.cpan.org/modules/by-module/Text/">http://www.cpan.org/modules/by-module/Text/</A></PRE>
<P></P>
<DT><STRONG><A NAME="item_CGI">CGI</A></STRONG><BR>
<DD>
The CGI plugin is a wrapper around Lincoln Stein's 
&lt;<A >lstein@genome.wi.mit.edu</A>&gt; CGI.pm module.  The plugin is 
distributed with the Template Toolkit (see <A >the Template::Plugin::CGI manpage</A>)
and the CGI module itself is distributed with recent versions Perl,
or is available from CPAN.
<PRE>
    [% USE CGI %]
    [% CGI.param('param_name') %]
    [% CGI.start_form %]
    [% CGI.popup_menu( Name   =&gt; 'color', 
                       Values =&gt; [ 'Green', 'Brown' ] ) %]
    [% CGI.end_form %]</PRE>
<P></P>
<DT><STRONG><A NAME="item_Datafile">Datafile</A></STRONG><BR>
<DD>
Provides an interface to data stored in a plain text file in a simple
delimited format.  The first line in the file specifies field names
which should be delimiter by any non-word character sequence.
Subsequent lines define data using the same delimiter as int he first
line.  Blank lines and comments (lines starting '#') are ignored.  See
<A >the Template::Plugin::Datafile manpage</A> for further details.
<P>/tmp/mydata:</P>
<PRE>
    # define names for each field
    id : email : name : tel
    # here's the data
    fred : fred@here.com : Fred Smith : 555-1234
    bill : bill@here.com : Bill White : 555-5678</PRE>
<P>example:</P>
<PRE>
    [% USE userlist = datafile('/tmp/mydata') %]</PRE>
<PRE>
    [% FOREACH user = userlist %]
       [% user.name %] ([% user.id %])
    [% END %]</PRE>
<P></P>
<DT><STRONG><A NAME="item_Date">Date</A></STRONG><BR>
<DD>
The Date plugin provides an easy way to generate formatted time and date
strings by delegating to the POSIX <CODE>strftime()</CODE> routine.   See
<A >the Template::Plugin::Date manpage</A> and <EM>POSIX</EM> for further details.
<PRE>
    [% USE date %]
    [% date.format %]           # current time/date</PRE>
<PRE>
    File last modified: [% date.format(template.modtime) %]</PRE>
<P></P>
<DT><STRONG><A NAME="item_DBI">DBI</A></STRONG><BR>
<DD>
The DBI plugin, developed by Simon Matthews
&lt;<A >sam@knowledgepool.com</A>&gt;, brings the full power of Tim Bunce's
&lt;<A >Tim.Bunce@ig.co.uk</A>&gt; database interface module (DBI) to your
templates.  See <A >the Template::Plugin::DBI manpage</A> and <A HREF="#item_DBI">DBI</A> for further details.
<PRE>
    [% USE DBI('dbi:driver:database', 'user', 'pass') %]</PRE>
<PRE>
    [% FOREACH user = DBI.query( 'SELECT * FROM users' ) %]
       [% user.id %] [% user.name %]
    [% END %]</PRE>
<P>The DBI and relevant DBD modules are available from CPAN:</P>
<PRE>
  <A HREF="http://www.cpan.org/modules/by-module/DBI/">http://www.cpan.org/modules/by-module/DBI/</A></PRE>
<P></P>
<DT><STRONG><A NAME="item_Dumper">Dumper</A></STRONG><BR>
<DD>
The Dumper plugin provides an interface to the Data::Dumper module.  See
<A >the Template::Plugin::Dumper manpage</A> and <A >the Data::Dumper manpage</A> for futher details.
<PRE>
    [% USE dumper(indent=0, pad=&quot;&lt;br&gt;&quot;) %]
    [% dumper.dump(myvar, yourvar) %]</PRE>
<P></P>
<DT><STRONG><A NAME="item_Format">Format</A></STRONG><BR>
<DD>
The Format plugin provides a simple way to format text according to a
printf()-like format.   See <A >the Template::Plugin::Format manpage</A> for further 
details.
<PRE>
    [% USE bold = format('&lt;b&gt;%s&lt;/b&gt;') %]
    [% bold('Hello') %]</PRE>
<P></P>
<DT><STRONG><A NAME="item_Iterator">Iterator</A></STRONG><BR>
<DD>
The Iterator plugin provides a way to create a Template::Iterator
object to iterate over a data set.  An iterator is created
automatically by the FOREACH directive and is aliased to the 'loop'
variable.  This plugin allows an iterator to be explicitly created
with a given name, or the default plugin name, 'iterator'.  See
<A >the Template::Plugin::Iterator manpage</A> for further details.
<PRE>
    [% USE iterator(list, args) %]</PRE>
<PRE>
    [% FOREACH item = iterator %]
       [% '&lt;ul&gt;' IF iterator.first %]
       &lt;li&gt;[% item %]
       [% '&lt;/ul&gt;' IF iterator.last %]
    [% END %]</PRE>
<P></P>
<DT><STRONG><A NAME="item_Table">Table</A></STRONG><BR>
<DD>
The Table plugin allows you to format a list of data items into a 
virtual table by specifying a fixed number of rows or columns, with 
an optional overlap.  See <A >the Template::Plugin::Table manpage</A> for further 
details.
<PRE>
    [% USE table(list, rows=10, overlap=1) %]</PRE>
<PRE>
    [% FOREACH item = table.col(3) %]
       [% item %]
    [% END %]</PRE>
<P></P>
<DT><STRONG><A NAME="item_URL">URL</A></STRONG><BR>
<DD>
The URL plugin provides a simple way of contructing URLs from a base
part and a variable set of parameters.  See <A >the Template::Plugin::URL manpage</A>
for further details.
<PRE>
    [% USE mycgi = url('/cgi-bin/bar.pl', debug=1) %]</PRE>
<PRE>
    [% mycgi %]
       # ==&gt; /cgi/bin/bar.pl?debug=1</PRE>
<PRE>
    [% mycgi(mode='submit') %]
       # ==&gt; /cgi/bin/bar.pl?mode=submit&amp;debug=1</PRE>
<P></P>
<DT><STRONG><A NAME="item_Wrap">Wrap</A></STRONG><BR>
<DD>
The Wrap plugin uses the Text::Wrap module by David Muir Sharnoff 
&lt;<A >muir@idiom.com</A>&gt; (with help from Tim Pierce and many many others)
to provide simple paragraph formatting.  See <A >the Template::Plugin::Wrap manpage</A>
and <A >the Text::Wrap manpage</A> for further details.
<PRE>
    [% USE wrap %]
    [% wrap(mytext, 40, '* ', '  ') %]  # use wrap sub
    [% mytext FILTER wrap(40) -%]       # or wrap FILTER</PRE>
<P>The Text::Wrap module is available from CPAN:</P>
<PRE>
    <A HREF="http://www.cpan.org/modules/by-module/Text/">http://www.cpan.org/modules/by-module/Text/</A></PRE>
<P></P>
<DT><STRONG><A NAME="item_XML%3A%3ADOM">XML::DOM</A></STRONG><BR>
<DD>
The XML::DOM plugin gives access to the XML Document Object Module via
Clark Cooper &lt;<A >cooper@sch.ge.com</A>&gt; and Enno Derksen's 
&lt;<A >enno@att.com</A>&gt; XML::DOM module.  See <A >the Template::Plugin::XML::DOM manpage</A> 
and <A >the XML::DOM manpage</A> for further details.
<PRE>
    [% USE dom = XML.DOM %]
    [% doc = dom.parse(filename) %]</PRE>
<PRE>
    [% FOREACH node = doc.getElementsByTagName('CODEBASE') %]
       * [% node.getAttribute('href') %]
    [% END %]</PRE>
<P>The plugin requires the XML::DOM module, available from CPAN:</P>
<PRE>
    <A HREF="http://www.cpan.org/modules/by-module/XML/">http://www.cpan.org/modules/by-module/XML/</A></PRE>
<P></P>
<DT><STRONG><A NAME="item_XML%3A%3AXPath">XML::XPath</A></STRONG><BR>
<DD>
The XML::XPath plugin provides an interface to Matt Sergeant's
&lt;<A >matt@sergeant.org</A>&gt; XML::XPath module.  See 
<A >the Template::Plugin::XML::XPath manpage</A> and <A >the XML::XPath manpage</A> for further details.
<PRE>
    [% USE xpath = XML.XPath(xmlfile) %]
    [% FOREACH page = xpath.findnodes('/html/body/page') %]
       [% page.getAttribute('title') %]
    [% END %]</PRE>
<P>The plugin requires the XML::XPath module, available from CPAN:</P>
<PRE>
    <A HREF="http://www.cpan.org/modules/by-module/XML/">http://www.cpan.org/modules/by-module/XML/</A></PRE>
<P></P>
<DT><STRONG><A NAME="item_XML%3A%3ARSS">XML::RSS</A></STRONG><BR>
<DD>
The XML::RSS plugin is a simple interface to Jonathan Eisenzopf's
&lt;<A >eisen@pobox.com</A>&gt; XML::RSS module.  A RSS (Rich Site Summary)
file is typically used to store short news 'headlines' describing
different links within a site.  This plugin allows you to parse RSS
files and format the contents accordingly using templates.  
See <A >the Template::Plugin::XML::RSS manpage</A> and <A >the XML::RSS manpage</A> for further details.
<PRE>
    [% USE news = XML.RSS(filename) %]
</PRE>
<PRE>

    [% FOREACH item = news.items %]
       &lt;a href=&quot;[% item.link %]&quot;&gt;[% item.title %]&lt;/a&gt;
    [% END %]</PRE>
<P>The XML::RSS module is available from CPAN:</P>
<PRE>
    <A HREF="http://www.cpan.org/modules/by-module/XML/">http://www.cpan.org/modules/by-module/XML/</A></PRE>
<P></P></DL>
<P>
<HR>
<H1><A NAME="see also">SEE ALSO</A></H1>
<P>The Template Toolkit web site contains the latest information, news and 
other resources.</P>
<PRE>
    <A HREF="http://www.template-toolkit.org/">http://www.template-toolkit.org/</A></PRE>
<P>A mailing list exists for up-to-date information on the Template Toolkit
and for following and contributing to the development process.  To 
subscribe, send an email to</P>
<PRE>
    templates-request@template-toolkit.org</PRE>
<P>with the message 'subscribe' in the body.  You can also use the web 
interface to subscribe or browse the archives:</P>
<PRE>
    <A HREF="http://www.template-toolkit.org/mailman/listinfo/templates">http://www.template-toolkit.org/mailman/listinfo/templates</A></PRE>
<P>The <EM>tpage</EM> and <EM>ttree</EM> scripts are distributed and installed along
with the Template Toolkit.  The <EM>tpage</EM> script simply processes named 
files or STDIN if unspecified, using a default Template object.  The 
<EM>ttree</EM> script can be used to process entire directory trees of templates,
allowing large content systems such as web sites to be rebuilt from a 
single command or configuration file.</P>
<PRE>
    perldoc tpage
    perldoc ttree</PRE>
<P>The <EM>Template::Tutorial</EM> document provides an introduction to the Template
Toolkit and shows some typical examples of usage.</P>
<PRE>
    perldoc Template::Tutorial</PRE>
<P>You may also like to consult the paper 'Building and Managing Web Systems
with the Template Toolkit' and accompanying slides from the presentation
at the 4th Perl Conference.  These are available from the Template
Toolkit web site:</P>
<PRE>
    <A HREF="http://www.template-toolkit.org/docs.html">http://www.template-toolkit.org/docs.html</A></PRE>
<P>The following modules comprise the Template Toolkit.  Consult the
individual documentation for further details.</P>
<DL>
<DT><STRONG><A NAME="item_Template%3A%3AService%7CTemplate%3A%3AService"><A >Template::Service</A></A></STRONG><BR>
<DD>
The Template::Service module handles the template processing
lifecycle, adding PRE_PROCESS and POST_PROCESS templates, handling
redirection through any defined PROCESS template, and dispatching any
ERROR templates to handle uncaught exceptions.  The actual processing
of these templates is handled by an underlying <A >Template::Context</A>
object.
<P></P>
<DT><STRONG><A NAME="item_Template%3A%3AContext%7CTemplate%3A%3AContext"><A >Template::Context</A></A></STRONG><BR>
<DD>
The Template::Context module defines a class of objects which each
represent a unique run-time environment in which templates are
processed.  The context maintains references to the stash of variables
currently defined (<A >Template::Stash</A>) and to provider
objects for templates (<A >Template::Provider</A>), filters 
(<A >Template::Filters</A>) and plugins 
(<A >Template::Plugins</A>).
<P></P>
<DT><STRONG><A NAME="item_Template%3A%3AStash%7CTemplate%3A%3AStash"><A >Template::Stash</A></A></STRONG><BR>
<DD>
The Template::Stash module defines an object class which is used for 
storing, retrieving and evaluating variables and their values.
<P></P>
<DT><STRONG><A NAME="item_Template%3A%3AProvider%7CTemplate%3A%3AProvider"><A >Template::Provider</A></A></STRONG><BR>
<DD>
The Template::Provider module defines an object class which is used to
find, load, parse, compile and then cache template documents.  The
cache implements a simple <CODE>fetch($template)</CODE> method which will accept a
wide range of inputs (filename, text ref, GLOB, IO::Handle, etc) and
attempt to read the template and call on a <A >Template::Parser</A> to parse and compile it to a <A >Template::Document</A>
which is then cached.
<P></P>
<DT><STRONG><A NAME="item_Template%3A%3ADocument%7CTemplate%3A%3ADocument"><A >Template::Document</A></A></STRONG><BR>
<DD>
Template::Document objects are thin wrappers around the Perl
subroutines which have been compiled from source templates by the <A >Template::Parser</A>.  These objects also maintain any metadata
values for the template and have references to any BLOCKs
defined within the the template.
<P></P>
<DT><STRONG><A NAME="item_Template%3A%3AParser%7CTemplate%3A%3AParser"><A >Template::Parser</A></A></STRONG><BR>
<DD>
The Template::Parser module defines an object class which implements
the template parser and compiler.  The template text is first scanned
by a Perl regex which extracts the embedded directives and lexes the
tokens contained within.  A DFA (Deterministic Finite-state Automaton)
then iterates through the tokens using the rules and states defined in
<A >Template::Grammar</A> and generates a compiled template
document as a Perl subroutine.
<P></P>
<DT><STRONG><A NAME="item_Template%3A%3AGrammar%7CTemplate%3A%3AGrammar"><A >Template::Grammar</A></A></STRONG><BR>
<DD>
The Template::Grammar module defines the rules and state tables for 
the <A >Template::Parser</A> DFA.  These are generated 
by the Parse::Yapp module.  The Template-Toolkit distribution 
contains a <STRONG>parser</STRONG> directory which contains further files and 
information concerning the grammar and compilation thereof.
<P></P>
<DT><STRONG><A NAME="item_Template%3A%3ADirective%7CTemplate%3A%3ADirective"><A >Template::Directive</A></A></STRONG><BR>
<DD>
This module implements a number of factory methods which are used by
the <A >Template::Parser</A> to generate Perl code from source
templates.
<P></P>
<DT><STRONG><A NAME="item_Template%3A%3AFilters%7CTemplate%3A%3AFilters"><A >Template::Filters</A></A></STRONG><BR>
<DD>
This module implements the various FILTER subroutines and provides a 
simple interface through which filter subs can be retrieved.
<P></P>
<DT><STRONG><A NAME="item_Template%3A%3APlugins%7CTemplate%3A%3APlugins"><A >Template::Plugins</A></A></STRONG><BR>
<DD>
This module provides access to the standard Template Toolkit or user
defined plugin modules.
<P></P>
<DT><STRONG><A NAME="item_Template%3A%3APlugin%7CTemplate%3A%3APlugin"><A >Template::Plugin</A></A></STRONG><BR>
<DD>
Base class for Template::Plugin::* modules.
<P></P>
<DT><STRONG><A NAME="item_Template%3A%3AException%7CTemplate%3A%3AException"><A >Template::Exception</A></A></STRONG><BR>
<DD>
The Template::Exception module defines an exception type 
for representing error conditions within the Template Toolkit.
<P></P>
<DT><STRONG><A NAME="item_Template%3A%3AIterator%7CTemplate%3A%3AIterator"><A >Template::Iterator</A></A></STRONG><BR>
<DD>
The Template::Iterator module defines a data iterator which is used 
by the FOREACH directive.  This may be sub-classed to create more 
specialised iterators for traversing data sets.
<P></P>
<DT><STRONG><A NAME="item_Template%3A%3AConstants%7CTemplate%3A%3AConstants"><A >Template::Constants</A></A></STRONG><BR>
<DD>
Defines various constants used in the Template Toolkit.
<P></P>
<DT><STRONG><A NAME="item_Template%3A%3AConfig%7CTemplate%3A%3AConfig"><A >Template::Config</A></A></STRONG><BR>
<DD>
Implements a number of factory methods through which other Template::*
modules can be automatically loaded and instantiated.
<P></P>
<DT><STRONG><A NAME="item_Template%3A%3ABase%7CTemplate%3A%3ABase"><A >Template::Base</A></A></STRONG><BR>
<DD>
A common base class for many Template::* modules.
<P></P>
<DT><STRONG><A NAME="item_Template%3A%3ATest%7CTemplate%3A%3ATest"><A >Template::Test</A></A></STRONG><BR>
<DD>
Module for testing the Template Toolkit, primarily used by the test
scripts in the 't' distribution sub-directory.
<P></P></DL>
<P>
<HR>
<H1><A NAME="author">AUTHOR</A></H1>
<P>Andy Wardley &lt;<A >abw@kfs.org</A>&gt;</P>
<PRE>
    <A HREF="http://www.template-toolkit.org/">http://www.template-toolkit.org/</A>
    <A HREF="http://www.kfs.org/~abw/">http://www.kfs.org/~abw/</A></PRE>
<P>
<HR>
<H1><A NAME="copyright">COPYRIGHT</A></H1>
<PRE>
    Copyright (C) 1996-2000 Andy Wardley.  All Rights Reserved.
    Copyright (C) 1998-2000 Canon Research Centre Europe Ltd.</PRE>
<P>This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.</P>
<P>
<HR>
<H1><A NAME="acknowledgements">ACKNOWLEDGEMENTS</A></H1>
<P>The Template Toolkit was derived in part from ideas and techniques
developed in the Text::MetaText module.  This itself was the public
manifestation of an earlier template processing system I developed
while working at Peritas Ltd. (http://www.knowledgepool.com/).</P>
<P>In later years, the Template Toolkit was developed at Canon Research
Centre Europe Ltd. (http://www.cre.canon.co.uk) as part of a general
research theme into Web-related publishing and dynamic content
generation.</P>
<P>Many people have contributed ideas, inspiration, fixes and features to
the Template Toolkit.  Their efforts continue to be very much appreciated.  
Please let me know if you think anyone is missing from this list.</P>
<PRE>
  Chuck Adams               &lt;scrytch@uswest.net&gt;
  Thierry-Michel Barral     &lt;kktos@electron-libre.com&gt;
  Stas Beckman              &lt;stas@stason.org&gt;
  Neil Bowers               &lt;neilb@cre.canon.co.uk&gt;
  Leon Brocard              &lt;acme@astray.com&gt;  
  Chris Dean                &lt;ctdean@babycenter.com&gt;  
  Francois Desarmenien      &lt;desar@club-internet.fr&gt;
  Horst Dumcke              &lt;hdumcke@cisco.com&gt; 
  Michael Fowler            &lt;michael@shoebox.net&gt;    
  Perrin Harkins            &lt;pharkins@etoys.com&gt;
  Rafael Kitover            &lt;caelum@debian.org&gt;
  Hans von Lengerke         &lt;hans@lengerke.org&gt;
  Jonas Liljegren           &lt;jonas@paranormal.se&gt;
  Simon Matthews            &lt;sam@knowledgepool.com&gt;
  Craig McLane              &lt;mclanec@oxy.edu&gt;     
  Leslie Michael Orchard    &lt;deus_x@ninjacode.com&gt;
  Eugene Miretskiy          &lt;eugene@invision.net&gt;
  Chris Nandor              &lt;pudge@pobox.com&gt;
  Martin Portman            &lt;mrp@cre.canon.co.uk&gt;
  Randal L. Schwartz        &lt;merlyn@stonehenge.com&gt;
  Paul Sharpe               &lt;paul@miraclefish.com&gt;
  Doug Steinwand            &lt;dsteinwand@etoys.com&gt;
  Drew Taylor               &lt;dtaylor@vialogix.com&gt;   
  Swen Thuemmler            &lt;Swen.Thuemmler@paderlinx.de&gt;   
  Jim Vaughan               &lt;jim@mrjim.com&gt; 
  Chris Winters             &lt;cwinters@intes.net&gt;</PRE>


</body>
</html>
